<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021牛客暑期多校训练营4 B</title>
    <url>/2021/07/27/2021Nowcoder4A/</url>
    <content><![CDATA[<h2 id="A-Course"><a href="#A-Course" class="headerlink" title="A Course"></a>A Course</h2><p><strong>生成函数</strong>来计数不同课的选择方案</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n x^i = \frac{1}{1-x^n}\\
f_i(x) =\prod_{i \to j}  f_j...</script><h2 id="B-Sample-Game"><a href="#B-Sample-Game" class="headerlink" title="B Sample Game"></a>B Sample Game</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>有一个随机数生成器可以生成$[1,n]$中所有数，每个数被生成的概率为$p_i$,该生成器如果生成的数均不小于之前生成的所有数，则继续生成，否则停止。记每一轮一共生成了$x$个数，则收益为$x^2$。问期望收益。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">
1 \leq n \leq 100</script><h3 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h3><p>这个题巧妙之处在于对长度发生概率的<strong>设而不求</strong>。</p>
<p>首先我们根据题意知道除了最后一个数之外，该生成序列是单调不降的。那么一旦我们知道了每一个数被生成了多少次，则生成序列唯一确定。因此我们可以用<strong>生成函数</strong>来描述这个期望。</p>
<p>注意到对于一种数，它的被生成的无限期望为</p>
<script type="math/tex; mode=display">
E(\infty)=\sum_{i=1}^{\infty}p_s^i \cdot x_s^i=\frac{1}{1-p_sx_s}</script><p>因此从<strong>序列长度</strong>为1到长度为无穷的期望组合的描述如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=\sum_{i=1}^{\infty} \big(\sum_{s_1+s_2+...+s_n=i} \prod_{k=1}^n p_k^{s_k}) \cdot x^i\\
&=\sum_{i=1}^{\infty}P(len>i)x^i\\
&=\prod_{i=1}^n (1+p_ix_i+p_i^2x_i^2+...+p_i^{\infty}x_i^{\infty})\\
&=\prod_{i=1}^n \frac{1}{1-p_ix}
\end{aligned}</script><p>但这个描述的目的只是间接的得到概率的关系，我们还是得考虑具体的期望公式，再设法往上面得到的这个$f(x)$上转化。</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=\sum_{i=0}^{\infty}\big(P(len>i) -P(len>i+1))\cdot i^2\\
&展开后按照P(len>i)合并项得到\\
&=\sum_{i=0}^{\infty}P(len>i)[(i+1)^2-i^2]\\
&=\sum_{i=0}^{\infty}P(len>i)(2i+1)\\
&=2\cdot f'(1)+f(1)
\end{aligned}</script><p>下面再考虑求$f’(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
令g_i(x)&=\frac{1}{1-p_ix}\\
则g_i'(x)&=\frac{p_i}{(1-p_ix)^2}\\
故f'(x)&=\sum_{i=1}^{n}g_i'(x)\cdot \prod_{j \not=i}g_j(x)\\
&=f(x)\cdot \sum_{i=1}^n \frac{p_i}{1-p_ix}
\end{aligned}</script><p>故答案就是</p>
<script type="math/tex; mode=display">
\big(1+2\cdot\sum_{i=1}^n \frac{p_i}{1-p_i})f(1)</script>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>概率</tag>
        <tag>设而不求</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 G Product</title>
    <url>/2021/07/27/nowcoder4g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定三个整数$n,k,D$,设数列$a_i,i=1,2,…,n$,求对于所有数列满足$\forall i \in [1,n],a_i \geq 0$​且$\sum_{i=1}^na_i=D$​的情况下，</p>
<script type="math/tex; mode=display">
\frac{D!}{\prod_{i=1}^n(a_i+k)!}</script><p>的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 50\\
0\leq k \leq 50\\
D \leq 10^8</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>此题比较神仙。首先分母上$(a_i+k)!$​不太好看，假设一个$a_i :=a_i+k$​.我们考虑一个<strong>组合模型</strong>，一个长度为D的数列，每个位置上可以填$[1,n]$中的任何正整数，一共有多少中填法。通过算两次，假设我们枚举$i$出现的次数为$a_i$​，或者直接乘法原理，那么这个组合模型的描述为</p>
<script type="math/tex; mode=display">
(\sum_{a_i\geq0}=D) \prod_{i=1}^n \frac{D!}{a_i!}=n^D</script><p>那么回到本题。如果不要求$a_i \geq 0$即$a_i+k \geq k$时，则答案就是$n^{D+nk}$</p>
<p>现在问题就是必须要求$a_i+k\geq k$。因此我们用容斥原理做。</p>
<p>由于$n,k$都比较小，所以不妨记$dp[i][j]$表示“有$i$个数不满足要求且这$i$个数的和是$j$”，对于剩下的$n-i$​个数可以满足要求也可以不满足要求，其和也是确定的$D+nk-j$.因此我们可以求出”至少有$i$​个数不满足要求时对答案的贡献”:</p>
<script type="math/tex; mode=display">
C_{n}^{i} \cdot \sum_j dp[i][j]\cdot(n-i)^{D+nk-j}</script><p>因此答案就是$n^{D+nk}$减去”至少一个违反条件的”加上“至少两个违反条件的”减去“至少三个违反条件的”…如此递推即可。</p>
<p>最后再乘上$\frac{D!}{(D+nk)!}$满足题意。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年7月训练</title>
    <url>/2021/07/27/2021%E5%B9%B47%E6%9C%88%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="202107月训练"><a href="#202107月训练" class="headerlink" title="202107月训练"></a>202107月训练</h1><h3 id="CF-1547F"><a href="#CF-1547F" class="headerlink" title="CF 1547F"></a>CF 1547F</h3><p>其实我们已经想到了本质是求<strong>最长的一段不是全局公约数的子序列</strong>长度，而且$O(\sum n)$的提示也容易使人明白需要用类似尺取的方法。但差点意思的是怎么尺取呢？</p>
<p>之前失败的思路，问题在于要考虑的质因数太多，并不能动态维护当前段的所有质因数。所以这时候我们需要估计对于每一个数，其<strong>质因数个数的上限</strong>——其实就是8个，所以一个一个考虑是足够的。那么问题需要转化，也就是首先所有的数都除掉全局公约数，这样就是求最长的一段$gcd&gt;1$的子序列。</p>
<p>那么我们按照线性筛得到的筛法树的边权<strong>（注意严格保存最小质因子）</strong>，容易得到每个数的因数分解，那么对于每一个数$a_i$,枚举它的所有质因数$p$，然后向左向右扩展，每扩展一个数，就把它的$p$从其质因数集合中消去，这样就可以不断更新最大长度。</p>
<p><strong>算法标签</strong> <code>数论</code> <code>线性筛</code> <code>双指针/尺取法</code></p>
<h3 id="CF-1547G"><a href="#CF-1547G" class="headerlink" title="CF 1547G"></a>CF 1547G</h3><p>基本思路是正确的，就是要用SCC来统一处理环。然后1是唯一确定的源点，这个条件很好，使得DFS和Tarjan过程仅从1开始就行。然后从1开始到某点的访问次数，由于只考虑2次以上有限次，所以DFS就可以统计，并不需要DP。最后凡是从1到某个点路径经过SCC（或者自环）的，$ans_i=-1$</p>
<p><code>算法标签</code> <code>图论</code> <code>强连通分量</code></p>
<h3 id="CF-1391D"><a href="#CF-1391D" class="headerlink" title="CF 1391D"></a>CF 1391D</h3><p>这个题其实还是一个奇偶的构造。</p>
<p>首先行数超过4行和行数只有1行的情况很容易处理。那么先考虑两行的情况。这时的偶方阵就是$2 \times 2$的方阵，所以如果有奇数个1，相邻$2\times1$的列的1个数奇偶性应该不同。所以整个矩阵最终效果，就是“奇偶奇偶”的情形，或者”偶奇偶奇”的情形。按照这两种情况扫一遍即可。</p>
<p>那么行数为3的情况怎么样呢？其实这里就是化归，前两行和后两行分别实现$n=2$时奇偶分布，所以是四种情况，同样扫就行。</p>
<p><strong>算法标签</strong> <code>奇偶分析</code></p>
<h3 id="CF-1550D"><a href="#CF-1550D" class="headerlink" title="CF 1550D"></a>CF 1550D</h3><p>这题核心在于一个偏移量的思想。设置$a_i=i+k_i$然后分析$k_i$的性质，来计数。具体思路见题解。</p>
<p><img src="https://tva1.sinaimg.cn/large/0066rFaply8gsvgpc69s5j30wb0ldjyg.jpg" alt="image-20210718152335714"></p>
<h3 id="CF-1550F"><a href="#CF-1550F" class="headerlink" title="CF 1550F"></a>CF 1550F</h3><p>这个题目很综合，也体现<strong>建图和图的处理的</strong>一些技巧。</p>
<p>首先怎么考虑每一次$[d-k,d+k]$这个范围的跳跃的构建。其实最<strong>朴素的想法</strong>是枚举两个节点，连接一条边，边权就是坐标差的绝对值。那么适配这个题目，就再把$d$考虑进去，变成$w=|d-|a_u-a_v||$。所以如果从$s$到$i$经过的若干边，他的边权$w$都不超过$k$，那么就是满足要求的。</p>
<p>考虑到每一次的$k$是变动的，$k$越大，相当于跳跃的约束越小。因此我们就考虑尽可能用$w$的边来构成从$s$到$i$的路径，这样就可以更大化地满足要求苛刻的$k$。于是我们可以考虑<strong>求一棵最小生成树</strong>。</p>
<p>但是个$n^2$量级的完全图，因此普通的Kruskal和Prim是不行的。我们用一个新算法——$Boruvka$。</p>
<p>Boruvka 算法的一句话思想便是：</p>
<p>“从<em>所有当前的连通块向其他连通块<strong>扩展出最小边</strong></em>，直到只剩一个连通块”，其中取最小边的贪心思想是 Kruskal 的主体，而向外扩展又是 Prim 的思想 —— 基于另外两种生成树算法，Boruvka 的正确性显然。</p>
<p>其代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 连通块个数&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        mn[i] = 连接 i 与其他连通块的最小边</span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        <span class="keyword">if</span> mn[i] 连接两个不同的连通块</span><br><span class="line">            ans += mn[i]</span><br><span class="line">            <span class="built_in">Merge</span>( mn[i] 连接的连通块 )</span><br><span class="line">            连通块个数 --</span><br></pre></td></tr></table></figure>
<p>而不同的题目难点就在于快速计算$mn_i$。对于这道题而言，其实$mn_i$就是要找到可以向其他连通块扩展的权值在$[a_i-d,a_i+d]$范围内的最小边。<strong>那么我们可以利用<code>set</code>+<code>lower_bound</code>来求这个最小边</strong>。</p>
<p>所以求得最小边后，就用vector维护的并查集来合并（小并入大）维护连通块，同时在新图上连接无向边。</p>
<p>运行完Boruvka算法后，再从$s$出发DFS遍历整个MST，求得它到其他点路径上的权值最大值。最后处理询问时只需要考虑这个权值最大值是不是比k来的小就行了。</p>
<p>复杂度$O(nlog^2n)$</p>
<p>算法标签 <code>最小生成树</code> <code>启发式合并</code> <code>图论建图</code></p>
<h3 id="CF-1550E"><a href="#CF-1550E" class="headerlink" title="CF 1550E"></a>CF 1550E</h3><p>这道题核心在于<strong>模拟匹配</strong>。</p>
<p>从<a href="https://frozenguardian.blog.csdn.net/">Frozen_Guardian</a>的博客上学到了关于这种<strong>状压</strong>的一些真知灼见。</p>
<blockquote>
<p>状压$dp$就是全排列问题的一种优化，所以状压$dp$可以解决的问题，全排列暴力枚举肯定也是可以解决的。所以先将问题简化，假设本题放开全排列该如何去做？</p>
</blockquote>
<p>我们要全排列什么？其实相当于<strong>从左到右依次放置待判定长度的相同字母子串</strong>。所以问题的关键就在于判别不同排列时能不能恰好匹配？所以这里就借助了序列自动机的概念。我们记$nnext[i][j]$表示从字符串第$i$个字符开始，其<strong>最早</strong>完全匹配第$j$种字符的待判定长度的字串时，下一个位置是多少？那么计算就是从后往前计算，如果借助？和已有的字母能够新增出一个完全的匹配，那么就赋值，否则照搬$nnext[i+1][j]$。</p>
<p>再考虑$dp$的转移，很容易想到$dp[mask]$就是已经使用字母的状态，这个dp值的含义是完成状态内这些字母的匹配后，<strong>最小的下一个位置</strong>（相当于一个$end$指针）。所以说我们其实并不关心从左到右到底是如何安排的，只需要按照$nnext$来辅助转移就可以了。</p>
<p>所以最后的判定标准就是如果$dp[2^k-1]$在$n-1$范围内，就是可以的。主函数二分答案即可。</p>
<p><strong>算法标签</strong> <code>二分答案</code> <code>序列自动机</code> <code>状压DP</code></p>
<h2 id="Nowcoder-Summer-2"><a href="#Nowcoder-Summer-2" class="headerlink" title="Nowcoder Summer 2"></a>Nowcoder Summer 2</h2><h3 id="J-Product-of-GCDs"><a href="#J-Product-of-GCDs" class="headerlink" title="J Product of GCDs"></a>J Product of GCDs</h3><p>给定一个集合，求其所有大小为$k$的子集的$gcd$之积</p>
<p>基本思路在赛场上就讨论的很清楚了，事后看题解也大致是这个思路。但赛场上没写出来的原因，是欧拉函数不会求。</p>
<p>把所有的数按照<strong>所含的质因子分类</strong>，朴素来说就是每一个质数开一个桶，把凡是含有这个质因子的数往这个桶里装，然后这个桶不断的处理该质因子的若干次幂的情况，相当于每一次把桶里所有数除一遍这个质数，然后删掉不再含有该质因子的数，每一次操作后对桶的大小做一个组合数的快速幂：</p>
<script type="math/tex; mode=display">
ans \gets prime^{C_{size}^k}</script><p>这个组合数数值很大，难以存储，又考虑这个组合数在指数的位置上，所以先求出$\varphi(p)$,然后用公式$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$来递推取模得到所需的组合数，对一组数据复杂度为$O(nk)$</p>
<p>此外关于实现，其实朴素想法中的“桶”是不需要用<code>STL​</code>的什么容器来实现的。只需要每次枚举质数和质数的幂次即可。因为用了容器，反而会多出来一些复杂度。</p>
<p><strong>算法标签</strong> <code>欧拉函数</code> <code>组合数</code> </p>
<h3 id="G-League-of-Legends"><a href="#G-League-of-Legends" class="headerlink" title="G League of Legends"></a>G League of Legends</h3><p>将$n$条线段分成$k$组，每组线段求一个交，求最大化所有交之和。</p>
<p>其实这个分组问题很容易想到的是用DP解法。那么DP解法我们不能<strong>枚举</strong>分组情况，从经验而言，一般是考虑<strong>连续的一系列线段</strong>构成最后一组这样子。那么怎么做才能使这样的DP成立呢？</p>
<p>首先我们把线段分成两类：一类线段可以包含其他的线段。那么如果把这个线段和其所包含的线段安排在一组，则不会对答案有新的贡献，要么把它单独分组，贡献其长度。另一类线段就是相互之间均不能包含，但可以有相交的部分。我们考虑把这些线段按左端点从小到大排序，那么右端点一定是单调不降的。这个时候，我们分析贪心，在这些线段中分组，一定是把连续的线段分成一组。因为通过画图可以知道，如果把排序后两条不相邻$i$,$j$的线段分成一组，那么我们取$k,i &lt;k&lt;j$，就会发现无论是$(i,k)$一组还是$(k,j)$一组，对答案的贡献都比$(i,j)$一组来的多。当然这里还有一个显然的事情就是一个组的线段越多，相交部分肯定倾向于越少。</p>
<p>于是我们就有了DP方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=max_{k<i}\{dp[k][j-1]+R[k+1]\}-L[i],R[k+1] \geq L[i]</script><p>其中，$dp[i][j]$表示把第二类线段的前$i$条线段分成$j$组的最优情况。</p>
<p>那么这个方程我们可以用单调队列优化。</p>
<p>复杂度为$O(n^2)$</p>
<p><strong>算法标签</strong> <code>递推与动规</code> <code>贪心</code> <code>单调队列</code></p>
<h2 id="数论知识回顾"><a href="#数论知识回顾" class="headerlink" title="数论知识回顾"></a>数论知识回顾</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>基本定义：对于一个正整数$n$,$\varphi(n)$代表比$n$小的且与$n$互质的正整数的个数。</p>
<p>计算性质：</p>
<script type="math/tex; mode=display">
\varphi(n)=\begin{cases}
n-1,&\text{n is a prime}\\
(p-1)p^{k-1},& n=p^k,\text{p is a prime}\\
\varphi(s)\cdot \varphi(t),&\text{n=st and (s,t)=1}\\
\varphi(k) ,&n=2k,\text{k is an odd}
\end{cases}</script><p>定义式：</p>
<script type="math/tex; mode=display">
\varphi(n)=n \cdot \prod_{i=1}^k (1-\frac{1}{p_i})</script><p>其中，$p_i$是$n$的质因子。</p>
<h3 id="判断质数的方法：Miller-Rabin"><a href="#判断质数的方法：Miller-Rabin" class="headerlink" title="判断质数的方法：Miller  Rabin"></a>判断质数的方法：Miller  Rabin</h3><h3 id="大整数质因数分解（探寻其质因子）-Pollard-Rho"><a href="#大整数质因数分解（探寻其质因子）-Pollard-Rho" class="headerlink" title="大整数质因数分解（探寻其质因子） Pollard Rho"></a>大整数质因数分解（探寻其质因子） Pollard Rho</h3><h3 id="特殊情况的组合数取模-Lucas"><a href="#特殊情况的组合数取模-Lucas" class="headerlink" title="特殊情况的组合数取模 Lucas"></a>特殊情况的组合数取模 Lucas</h3><script type="math/tex; mode=display">
C_n^m \equiv C_{n/p}^{m/p}\cdot C_{n \;mod\;p}^{m\;mod\;p}\;(mod \;p),\text{p is a prime}</script><h2 id="单调队列优化DP"><a href="#单调队列优化DP" class="headerlink" title="单调队列优化DP"></a>单调队列优化DP</h2><p>题目比如参考上面的G题</p>
<p>这个题的特点是左端点是单调不降的，右端点也是单调不降的。因此我们的单调队列里存下标值，比较的条件是$dp[k][…]+R[k+1]$,限制的条件是$R[k+1] \geq L[i]$,假设当前正在考虑第$i$条线段。</p>
<p>这个单调队列不适合用<code>STL</code>，原因是它两端都要删除添加，还是用数组手写比较方便。</p>
<p>从<strong>队首到队尾</strong>，<code>dp+R</code>这个值<strong>单调递减</strong>，同时下标是<strong>单调递增</strong>的。原因：分同样多的组，当我们可用的线段更多时，方案数更丰富，因此可以得到更好的答案。</p>
<p>二重循环第一重是考虑第几条线段，第二重是考虑分几组。而且需要注意的是，分几组要<strong>从大到小</strong>来，因为处理完第$i$条线段的信息时，第$i$条线段对应的<code>dp+R</code>也会更新到这一系列队列中，对于同样是$i$而分更多组的计算造成干扰（避免后效性）。</p>
<p>队列操作：每一次先在<strong>队首</strong>剔除掉虽然<code>dp+R</code>很大，但不满足$R[k+1]\geq L[i]$的元素，然后算出当前的$dp$值，再在<strong>队尾</strong>更新，把原本队尾<code>dp+R</code>更小的剔除掉。因为这些决策点下标又小，又不利于贡献后面的答案。</p>
<h2 id="Vector的简易写法和for的C-0x用法"><a href="#Vector的简易写法和for的C-0x用法" class="headerlink" title="Vector的简易写法和for的C++0x用法"></a>Vector的简易写法和for的C++0x用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(n);  <span class="comment">//使得其大小为n，访问[0,n-1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//大小为n的vector，访问同上</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">7</span>)</span></span>;<span class="comment">//一个元素，值为7</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : comp)   <span class="comment">//x为comp容器的遍历器，下面直接访问x如何</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:&#123;-d,d&#125;)<span class="comment">//数值范围内遍历</span></span><br><span class="line"><span class="comment">//如果是vector&lt;vector &lt;xxx&gt; &gt; Q；这样的二维vector情形，则考虑</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;comp : comps) &#123;  <span class="comment">//不过遇事不决用auto 就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>1、<code>vector</code>的<code>size</code>是<code>unsigned int</code>类型。</p>
<p>2、STL Vector可能有重分配地址,*it 遍历器可能失效.</p>
<h2 id="计算几何学习"><a href="#计算几何学习" class="headerlink" title="计算几何学习"></a>计算几何学习</h2><p>见手写笔记</p>
<h2 id="编码细节"><a href="#编码细节" class="headerlink" title="编码细节"></a>编码细节</h2><p>1、<code>unsigned long long</code> 用<code>printf</code>输出时控制符为$\%llu$</p>
<p>2、最小值的预命令形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<p>3、Windows 命令行屏幕输出文字： <code>echo</code>+文字内容（不用引号）</p>
<p>4、LL的溢出，考虑用(__int128)或者慢速乘来解决。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__int128)a*b%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还要注意乘除的顺序，必要的时候先除后乘。</p>
<p>两个<code>int</code>相乘在<code>long long</code>的范围内判定，简单明确的写法是<code>1LL*i*j&gt;N</code>这类。</p>
<p>5、取模简化运算：预命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod1(x) (x&gt;=MOD)&amp;&amp;(x-=MOD)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 H题</title>
    <url>/2021/07/27/test/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>考虑$x=\prod_{i}p_i^{a_i}$,$y=\prod_{i}p_i^{b_i}$.定义$x \bigotimes y$=$\prod_{i}p_i^{|a_i-b_i|}$,现在给定一个数列$a[1…n]$，求出</p>
<script type="math/tex; mode=display">
b[i]=\sum_{1 \leq j,k \leq n,j \bigotimes k=i}a_jk^c</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先通过$|a_i-b_i|=max(a_i,b_i)-min(a_i,b_i)$来理解这个定义本质是$\frac{lcm(a,b)}{gcd(a,b)}$,故进一步得到</p>
<script type="math/tex; mode=display">
i=\frac{j}{gcd} \cdot \frac{k}{gcd}</script><p>那么不妨令</p>
<script type="math/tex; mode=display">
s=\frac{j}{gcd},t=\frac{k}{gcd}</script><p>故</p>
<script type="math/tex; mode=display">
i=s \cdot t \\(s,t)=1</script><p>因此</p>
<script type="math/tex; mode=display">
b[i]=\sum_s (\frac{i}{s})^c \sum_{gcd} (a_{s \cdot gcd})\cdot gcd^c</script><p>由此可见后面这个$gcd$的部分可以通过对于一个数枚举其倍数预处理得到，其复杂度为</p>
<script type="math/tex; mode=display">
n \cdot \sum_{i=1}^N \frac{1}{i} =nlogn</script><p>前面这个$s$的枚举是$O(n\sqrt n)$,但并不满。因此总复杂度是可以接受的。</p>
<p>此外，对于$s,t$并没有大小之分，但是需要保证$s \cdot gcd ,t \cdot gcd \leq n$,因此需要在上述计算中选择较小的$gcd$上限来运算。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>本题在考场上低级错误在于快速幂。</p>
<p>枚举因子时<code>sqrt</code>应当提前算出！</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">    LL ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL b[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line">vector&lt;LL&gt; rela[MAXN];</span><br><span class="line">LL my_pow[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;H.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    LL now;</span><br><span class="line">    <span class="keyword">int</span> s,t,qrt;</span><br><span class="line">    n=<span class="built_in">mread</span>(),c=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)my_pow[i]=<span class="built_in">quick_pow</span>(i,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,k=<span class="number">1</span>; j&lt;=n; j+=i,k++) &#123; <span class="comment">//gcd enum</span></span><br><span class="line">            now=(now+<span class="number">1ll</span>*a[j]*my_pow[k]%MOD+MOD)%MOD;</span><br><span class="line">            rela[i].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        qrt=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=qrt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            s=j,t=i/j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gcd</span>(s,t)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s!=t) &#123;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[t]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[t][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span>  b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sum=sum^b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>test-2</title>
    <url>/2021/07/28/test-2/</url>
    <content><![CDATA[<h2 id="本文继续测试其首页排序算法是否正确"><a href="#本文继续测试其首页排序算法是否正确" class="headerlink" title="本文继续测试其首页排序算法是否正确"></a>本文继续测试其首页排序算法是否正确</h2>]]></content>
  </entry>
  <entry>
    <title>About Me！(&gt;ω&lt;*)</title>
    <url>/2021/07/27/about/</url>
    <content><![CDATA[<p>LaiAng8086</p>
<p>BUAA SCSE 2020</p>
]]></content>
  </entry>
</search>
