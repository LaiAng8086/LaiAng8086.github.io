<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年7月训练</title>
    <url>/2021/07/27/2021%E5%B9%B47%E6%9C%88%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="202107月训练"><a href="#202107月训练" class="headerlink" title="202107月训练"></a>202107月训练</h1><h3 id="CF-1547F"><a href="#CF-1547F" class="headerlink" title="CF 1547F"></a>CF 1547F</h3><p>其实我们已经想到了本质是求<strong>最长的一段不是全局公约数的子序列</strong>长度，而且$O(\sum n)$的提示也容易使人明白需要用类似尺取的方法。但差点意思的是怎么尺取呢？</p>
<p>之前失败的思路，问题在于要考虑的质因数太多，并不能动态维护当前段的所有质因数。所以这时候我们需要估计对于每一个数，其<strong>质因数个数的上限</strong>——其实就是8个，所以一个一个考虑是足够的。那么问题需要转化，也就是首先所有的数都除掉全局公约数，这样就是求最长的一段$gcd&gt;1$的子序列。</p>
<p>那么我们按照线性筛得到的筛法树的边权<strong>（注意严格保存最小质因子）</strong>，容易得到每个数的因数分解，那么对于每一个数$a_i$,枚举它的所有质因数$p$，然后向左向右扩展，每扩展一个数，就把它的$p$从其质因数集合中消去，这样就可以不断更新最大长度。</p>
<p><strong>算法标签</strong> <code>数论</code> <code>线性筛</code> <code>双指针/尺取法</code></p>
<h3 id="CF-1547G"><a href="#CF-1547G" class="headerlink" title="CF 1547G"></a>CF 1547G</h3><p>基本思路是正确的，就是要用SCC来统一处理环。然后1是唯一确定的源点，这个条件很好，使得DFS和Tarjan过程仅从1开始就行。然后从1开始到某点的访问次数，由于只考虑2次以上有限次，所以DFS就可以统计，并不需要DP。最后凡是从1到某个点路径经过SCC（或者自环）的，$ans_i=-1$</p>
<p><code>算法标签</code> <code>图论</code> <code>强连通分量</code></p>
<h3 id="CF-1391D"><a href="#CF-1391D" class="headerlink" title="CF 1391D"></a>CF 1391D</h3><p>这个题其实还是一个奇偶的构造。</p>
<p>首先行数超过4行和行数只有1行的情况很容易处理。那么先考虑两行的情况。这时的偶方阵就是$2 \times 2$的方阵，所以如果有奇数个1，相邻$2\times1$的列的1个数奇偶性应该不同。所以整个矩阵最终效果，就是“奇偶奇偶”的情形，或者”偶奇偶奇”的情形。按照这两种情况扫一遍即可。</p>
<p>那么行数为3的情况怎么样呢？其实这里就是化归，前两行和后两行分别实现$n=2$时奇偶分布，所以是四种情况，同样扫就行。</p>
<p><strong>算法标签</strong> <code>奇偶分析</code></p>
<h3 id="CF-1550D"><a href="#CF-1550D" class="headerlink" title="CF 1550D"></a>CF 1550D</h3><p>这题核心在于一个偏移量的思想。设置$a_i=i+k_i$然后分析$k_i$的性质，来计数。具体思路见题解。</p>
<p><img src="https://tva1.sinaimg.cn/large/0066rFaply8gsvgpc69s5j30wb0ldjyg.jpg" alt="image-20210718152335714"></p>
<h3 id="CF-1550F"><a href="#CF-1550F" class="headerlink" title="CF 1550F"></a>CF 1550F</h3><p>这个题目很综合，也体现<strong>建图和图的处理的</strong>一些技巧。</p>
<p>首先怎么考虑每一次$[d-k,d+k]$这个范围的跳跃的构建。其实最<strong>朴素的想法</strong>是枚举两个节点，连接一条边，边权就是坐标差的绝对值。那么适配这个题目，就再把$d$考虑进去，变成$w=|d-|a_u-a_v||$。所以如果从$s$到$i$经过的若干边，他的边权$w$都不超过$k$，那么就是满足要求的。</p>
<p>考虑到每一次的$k$是变动的，$k$越大，相当于跳跃的约束越小。因此我们就考虑尽可能用$w$的边来构成从$s$到$i$的路径，这样就可以更大化地满足要求苛刻的$k$。于是我们可以考虑<strong>求一棵最小生成树</strong>。</p>
<p>但是个$n^2$量级的完全图，因此普通的Kruskal和Prim是不行的。我们用一个新算法——$Boruvka$。</p>
<p>Boruvka 算法的一句话思想便是：</p>
<p>“从<em>所有当前的连通块向其他连通块<strong>扩展出最小边</strong></em>，直到只剩一个连通块”，其中取最小边的贪心思想是 Kruskal 的主体，而向外扩展又是 Prim 的思想 —— 基于另外两种生成树算法，Boruvka 的正确性显然。</p>
<p>其代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 连通块个数&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        mn[i] = 连接 i 与其他连通块的最小边</span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        <span class="keyword">if</span> mn[i] 连接两个不同的连通块</span><br><span class="line">            ans += mn[i]</span><br><span class="line">            <span class="built_in">Merge</span>( mn[i] 连接的连通块 )</span><br><span class="line">            连通块个数 --</span><br></pre></td></tr></table></figure>
<p>而不同的题目难点就在于快速计算$mn_i$。对于这道题而言，其实$mn_i$就是要找到可以向其他连通块扩展的权值在$[a_i-d,a_i+d]$范围内的最小边。<strong>那么我们可以利用<code>set</code>+<code>lower_bound</code>来求这个最小边</strong>。</p>
<p>所以求得最小边后，就用vector维护的并查集来合并（小并入大）维护连通块，同时在新图上连接无向边。</p>
<p>运行完Boruvka算法后，再从$s$出发DFS遍历整个MST，求得它到其他点路径上的权值最大值。最后处理询问时只需要考虑这个权值最大值是不是比k来的小就行了。</p>
<p>复杂度$O(nlog^2n)$</p>
<p>算法标签 <code>最小生成树</code> <code>启发式合并</code> <code>图论建图</code></p>
<h3 id="CF-1550E"><a href="#CF-1550E" class="headerlink" title="CF 1550E"></a>CF 1550E</h3><p>这道题核心在于<strong>模拟匹配</strong>。</p>
<p>从<a href="https://frozenguardian.blog.csdn.net/">Frozen_Guardian</a>的博客上学到了关于这种<strong>状压</strong>的一些真知灼见。</p>
<blockquote>
<p>状压$dp$就是全排列问题的一种优化，所以状压$dp$可以解决的问题，全排列暴力枚举肯定也是可以解决的。所以先将问题简化，假设本题放开全排列该如何去做？</p>
</blockquote>
<p>我们要全排列什么？其实相当于<strong>从左到右依次放置待判定长度的相同字母子串</strong>。所以问题的关键就在于判别不同排列时能不能恰好匹配？所以这里就借助了序列自动机的概念。我们记$nnext[i][j]$表示从字符串第$i$个字符开始，其<strong>最早</strong>完全匹配第$j$种字符的待判定长度的字串时，下一个位置是多少？那么计算就是从后往前计算，如果借助？和已有的字母能够新增出一个完全的匹配，那么就赋值，否则照搬$nnext[i+1][j]$。</p>
<p>再考虑$dp$的转移，很容易想到$dp[mask]$就是已经使用字母的状态，这个dp值的含义是完成状态内这些字母的匹配后，<strong>最小的下一个位置</strong>（相当于一个$end$指针）。所以说我们其实并不关心从左到右到底是如何安排的，只需要按照$nnext$来辅助转移就可以了。</p>
<p>所以最后的判定标准就是如果$dp[2^k-1]$在$n-1$范围内，就是可以的。主函数二分答案即可。</p>
<p><strong>算法标签</strong> <code>二分答案</code> <code>序列自动机</code> <code>状压DP</code></p>
<h2 id="Nowcoder-Summer-2"><a href="#Nowcoder-Summer-2" class="headerlink" title="Nowcoder Summer 2"></a>Nowcoder Summer 2</h2><h3 id="J-Product-of-GCDs"><a href="#J-Product-of-GCDs" class="headerlink" title="J Product of GCDs"></a>J Product of GCDs</h3><p>给定一个集合，求其所有大小为$k$的子集的$gcd$之积</p>
<p>基本思路在赛场上就讨论的很清楚了，事后看题解也大致是这个思路。但赛场上没写出来的原因，是欧拉函数不会求。</p>
<p>把所有的数按照<strong>所含的质因子分类</strong>，朴素来说就是每一个质数开一个桶，把凡是含有这个质因子的数往这个桶里装，然后这个桶不断的处理该质因子的若干次幂的情况，相当于每一次把桶里所有数除一遍这个质数，然后删掉不再含有该质因子的数，每一次操作后对桶的大小做一个组合数的快速幂：</p>
<script type="math/tex; mode=display">
ans \gets prime^{C_{size}^k}</script><p>这个组合数数值很大，难以存储，又考虑这个组合数在指数的位置上，所以先求出$\varphi(p)$,然后用公式$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$来递推取模得到所需的组合数，对一组数据复杂度为$O(nk)$</p>
<p>此外关于实现，其实朴素想法中的“桶”是不需要用<code>STL​</code>的什么容器来实现的。只需要每次枚举质数和质数的幂次即可。因为用了容器，反而会多出来一些复杂度。</p>
<p><strong>算法标签</strong> <code>欧拉函数</code> <code>组合数</code> </p>
<h3 id="G-League-of-Legends"><a href="#G-League-of-Legends" class="headerlink" title="G League of Legends"></a>G League of Legends</h3><p>将$n$条线段分成$k$组，每组线段求一个交，求最大化所有交之和。</p>
<p>其实这个分组问题很容易想到的是用DP解法。那么DP解法我们不能<strong>枚举</strong>分组情况，从经验而言，一般是考虑<strong>连续的一系列线段</strong>构成最后一组这样子。那么怎么做才能使这样的DP成立呢？</p>
<p>首先我们把线段分成两类：一类线段可以包含其他的线段。那么如果把这个线段和其所包含的线段安排在一组，则不会对答案有新的贡献，要么把它单独分组，贡献其长度。另一类线段就是相互之间均不能包含，但可以有相交的部分。我们考虑把这些线段按左端点从小到大排序，那么右端点一定是单调不降的。这个时候，我们分析贪心，在这些线段中分组，一定是把连续的线段分成一组。因为通过画图可以知道，如果把排序后两条不相邻$i$,$j$的线段分成一组，那么我们取$k,i &lt;k&lt;j$，就会发现无论是$(i,k)$一组还是$(k,j)$一组，对答案的贡献都比$(i,j)$一组来的多。当然这里还有一个显然的事情就是一个组的线段越多，相交部分肯定倾向于越少。</p>
<p>于是我们就有了DP方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=max_{k<i}\{dp[k][j-1]+R[k+1]\}-L[i],R[k+1] \geq L[i]</script><p>其中，$dp[i][j]$表示把第二类线段的前$i$条线段分成$j$组的最优情况。</p>
<p>那么这个方程我们可以用单调队列优化。</p>
<p>复杂度为$O(n^2)$</p>
<p><strong>算法标签</strong> <code>递推与动规</code> <code>贪心</code> <code>单调队列</code></p>
<h2 id="数论知识回顾"><a href="#数论知识回顾" class="headerlink" title="数论知识回顾"></a>数论知识回顾</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>基本定义：对于一个正整数$n$,$\varphi(n)$代表比$n$小的且与$n$互质的正整数的个数。</p>
<p>计算性质：</p>
<script type="math/tex; mode=display">
\varphi(n)=\begin{cases}
n-1,&\text{n is a prime}\\
(p-1)p^{k-1},& n=p^k,\text{p is a prime}\\
\varphi(s)\cdot \varphi(t),&\text{n=st and (s,t)=1}\\
\varphi(k) ,&n=2k,\text{k is an odd}
\end{cases}</script><p>定义式：</p>
<script type="math/tex; mode=display">
\varphi(n)=n \cdot \prod_{i=1}^k (1-\frac{1}{p_i})</script><p>其中，$p_i$是$n$的质因子。</p>
<h3 id="判断质数的方法：Miller-Rabin"><a href="#判断质数的方法：Miller-Rabin" class="headerlink" title="判断质数的方法：Miller  Rabin"></a>判断质数的方法：Miller  Rabin</h3><h3 id="大整数质因数分解（探寻其质因子）-Pollard-Rho"><a href="#大整数质因数分解（探寻其质因子）-Pollard-Rho" class="headerlink" title="大整数质因数分解（探寻其质因子） Pollard Rho"></a>大整数质因数分解（探寻其质因子） Pollard Rho</h3><h3 id="特殊情况的组合数取模-Lucas"><a href="#特殊情况的组合数取模-Lucas" class="headerlink" title="特殊情况的组合数取模 Lucas"></a>特殊情况的组合数取模 Lucas</h3><script type="math/tex; mode=display">
C_n^m \equiv C_{n/p}^{m/p}\cdot C_{n \;mod\;p}^{m\;mod\;p}\;(mod \;p),\text{p is a prime}</script><h2 id="单调队列优化DP"><a href="#单调队列优化DP" class="headerlink" title="单调队列优化DP"></a>单调队列优化DP</h2><p>题目比如参考上面的G题</p>
<p>这个题的特点是左端点是单调不降的，右端点也是单调不降的。因此我们的单调队列里存下标值，比较的条件是$dp[k][…]+R[k+1]$,限制的条件是$R[k+1] \geq L[i]$,假设当前正在考虑第$i$条线段。</p>
<p>这个单调队列不适合用<code>STL</code>，原因是它两端都要删除添加，还是用数组手写比较方便。</p>
<p>从<strong>队首到队尾</strong>，<code>dp+R</code>这个值<strong>单调递减</strong>，同时下标是<strong>单调递增</strong>的。原因：分同样多的组，当我们可用的线段更多时，方案数更丰富，因此可以得到更好的答案。</p>
<p>二重循环第一重是考虑第几条线段，第二重是考虑分几组。而且需要注意的是，分几组要<strong>从大到小</strong>来，因为处理完第$i$条线段的信息时，第$i$条线段对应的<code>dp+R</code>也会更新到这一系列队列中，对于同样是$i$而分更多组的计算造成干扰（避免后效性）。</p>
<p>队列操作：每一次先在<strong>队首</strong>剔除掉虽然<code>dp+R</code>很大，但不满足$R[k+1]\geq L[i]$的元素，然后算出当前的$dp$值，再在<strong>队尾</strong>更新，把原本队尾<code>dp+R</code>更小的剔除掉。因为这些决策点下标又小，又不利于贡献后面的答案。</p>
<h2 id="Vector的简易写法和for的C-0x用法"><a href="#Vector的简易写法和for的C-0x用法" class="headerlink" title="Vector的简易写法和for的C++0x用法"></a>Vector的简易写法和for的C++0x用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(n);  <span class="comment">//使得其大小为n，访问[0,n-1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//大小为n的vector，访问同上</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">7</span>)</span></span>;<span class="comment">//一个元素，值为7</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : comp)   <span class="comment">//x为comp容器的遍历器，下面直接访问x如何</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:&#123;-d,d&#125;)<span class="comment">//数值范围内遍历</span></span><br><span class="line"><span class="comment">//如果是vector&lt;vector &lt;xxx&gt; &gt; Q；这样的二维vector情形，则考虑</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;comp : comps) &#123;  <span class="comment">//不过遇事不决用auto 就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>1、<code>vector</code>的<code>size</code>是<code>unsigned int</code>类型。</p>
<p>2、STL Vector可能有重分配地址,*it 遍历器可能失效.</p>
<h2 id="计算几何学习"><a href="#计算几何学习" class="headerlink" title="计算几何学习"></a>计算几何学习</h2><p>见手写笔记</p>
<h2 id="编码细节"><a href="#编码细节" class="headerlink" title="编码细节"></a>编码细节</h2><p>1、<code>unsigned long long</code> 用<code>printf</code>输出时控制符为$\%llu$</p>
<p>2、最小值的预命令形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<p>3、Windows 命令行屏幕输出文字： <code>echo</code>+文字内容（不用引号）</p>
<p>4、LL的溢出，考虑用(__int128)或者慢速乘来解决。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__int128)a*b%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还要注意乘除的顺序，必要的时候先除后乘。</p>
<p>两个<code>int</code>相乘在<code>long long</code>的范围内判定，简单明确的写法是<code>1LL*i*j&gt;N</code>这类。</p>
<p>5、取模简化运算：预命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod1(x) (x&gt;=MOD)&amp;&amp;(x-=MOD)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
  </entry>
  <entry>
    <title>Welcome to LaiAng80586&#39;s Blog！(&gt;ω&lt;*)</title>
    <url>/2021/07/27/about/</url>
    <content><![CDATA[<h2 id="Self-Introduction"><a href="#Self-Introduction" class="headerlink" title="Self Introduction"></a>Self Introduction</h2><p>LaiAng80586</p>
<p>BUAA SCSE 2020</p>
]]></content>
  </entry>
  <entry>
    <title>Codeforces 1500C - Matrix Sorting</title>
    <url>/2021/08/03/cf1500c/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给你一个$n \times m$​的矩阵，你每次可以选择一列，这个矩阵的每一行会按照这一列进行稳定排序（相同元素相对位置不变），问$A$​矩阵如何进行操作能变成$B$​​矩阵.</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m \leq 1500</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题还是从<strong>最终的局面入手</strong>考虑。</p>
<p>我们考虑B矩阵的某一列$p$，如果这一列是有序的，那么不妨假定这一列进行了排序操作。考察这一列的每个相邻行，如果某个相邻行的两个元素并不相等，那么意味着<strong>这两个行的位置由这次排序唯一确定</strong>。</p>
<p>那么我们放眼于这两行的其他列。如果其他列$q$​​在这两行是逆序的，意味着一种<strong>可能</strong>：就是之前$q$列发生过排序，本来是顺序的，但是由于$p$列后来的排序导致$q$​列某些位置逆序了。由此可见，如果$q$列要进行排序，那么必须在$p$​​列之前。这样以来，我们就得到了不同列排序的依赖关系。我们可以用一个拓扑排序来得到所有列的依次排序顺次。</p>
<p><strong>需要注意</strong>的是，$p$​​列相邻行的位置确定只能用一次，之后拓扑过程中其他列即便也是这两行有不等元素的顺序关系，也不能减少依赖了。这是因为，相当于由$p$列遍历的其他列的逆序关系指定由$p$列的排序来造成的。</p>
<p>最终我们在A数组上验证一下能不能通过顺次执行这些排序来得到B即可。显然，执行的次数不会超过总列数$m$。排序过程相当于手写桶排序。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; G[MAXN],srt;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN],b[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> deg[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> pos[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,k;</span><br><span class="line">	n=<span class="built_in">mread</span>(),m=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)a[i][j]=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)b[i][j]=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">			<span class="keyword">if</span>(b[j][i] &gt; b[j+<span class="number">1</span>][i]) &#123;</span><br><span class="line">				G[j].<span class="built_in">push_back</span>(i);</span><br><span class="line">				deg[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(!deg[i])Q.<span class="built_in">push</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		u=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line">		srt.<span class="built_in">push_back</span>(u);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[i] &amp;&amp; b[i][u] &lt; b[i+<span class="number">1</span>][u]) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">auto</span> v:G[i]) &#123;</span><br><span class="line">					deg[v]--;</span><br><span class="line">					<span class="keyword">if</span>(!deg[v])</span><br><span class="line">						Q.<span class="built_in">push</span>(v);</span><br><span class="line">				&#125;</span><br><span class="line">				vis[i]=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">reverse</span>(srt.<span class="built_in">begin</span>(),srt.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)pos[<span class="number">0</span>][i]=i;</span><br><span class="line">	k=srt.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,k);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">		u=srt[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)num[j]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)num[a[pos[i][j]][u]]++;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)num[j]+=num[j<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=n; j&gt;=<span class="number">1</span>; j--)pos[i+<span class="number">1</span>][num[a[pos[i][j]][u]]--]=pos[i][j];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,pos[k][i]);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(a[pos[k][i]][j]!=b[i][j]) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : srt)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1501D - Two chandeliers</title>
    <url>/2021/08/04/cf1501c/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个有限数列$a,b$​,每个数列里的数均不相同，但是两个数列可能含有一样的数。现在把两个数列循环排列并依次对应，问对应的数第$k$次不相同的位置是多少。</p>
<script type="math/tex; mode=display">
1 \leq n,m \leq 10^6\\
1\leq k\leq 10^{12}</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>虽然这仅仅是个解两个方程的同余方程组，但还是费了些周折。</p>
<p>很明显的思路就是我们二分答案最后的位置，然后检查该位置之前扣除对应数相等的位置量是否还大于等于$k$.所以问题关键在于求解第一次对应数相等的位置（在$lcm(n,m)$之前）</p>
<p>对于一个同时出现在两个数列中的数而言，记其在$a$数列中出现的位置为$x$,在$b$数列中出现的位置为$y$,那么其实这个位置就是</p>
<script type="math/tex; mode=display">
\begin{cases}
pos \equiv x(mod \; n)\\
pos \equiv y(mod \; m)
\end{cases}</script><p>这个东西用扩展CRT求解即可。</p>
<p>具体而言：我们考虑</p>
<script type="math/tex; mode=display">
\begin{cases}
x\equiv b_1(mod \;a_1)\\
x\equiv b_2(mod \;a_2)
\end{cases}</script><p>它可以写成</p>
<script type="math/tex; mode=display">
a_1x_1+b_1=x\\
a_2x_2+b_2=x</script><p>首先移项忽略正负（之后讲<strong>调整</strong>）</p>
<script type="math/tex; mode=display">
a_1x_1+a_2x_2=b_2-b_1</script><p>存在解的条件就是</p>
<script type="math/tex; mode=display">
(a_1,a_2) | b_2-b_1</script><p>然后我们通过扩展欧几里得求出</p>
<script type="math/tex; mode=display">
a_1x_1+a_2x_2=(a1,a2)</script><p>的一组解$(x_1,x_2)$</p>
<p>假设我们最后用$x_1$来得到原本要求得$x$</p>
<p>现在回头考虑忽略正负的那个式子，如果老老实实作差，应该是：</p>
<script type="math/tex; mode=display">
a_1x_1=b_2-b_1+a_2x_2</script><p>因此可知</p>
<script type="math/tex; mode=display">
令d=(a1,a2)\\
\frac{a1}{d}\cdot x_1 \equiv \frac{b_2-b_1}{d} \;(mod \;\frac{a2}{d})</script><p><strong>由此可见，我们用扩展欧几里得求出来的$x_1$​​实际上是模$mod=\frac{a2}{d}$​​​意义下的，因此可以通过</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x1=(x1%mod+mod)%mod</span><br></pre></td></tr></table></figure>
<p><strong>来使得$x_1$​​变成一个正数。</strong></p>
<p>最后$x=a_1\cdot x_1\frac{b2-b1}{(a1,a2)}+b1$来得到$x$即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LL k;</span><br><span class="line"><span class="keyword">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="keyword">int</span> posa[MAXN&lt;&lt;<span class="number">1</span>],posb[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line">LL lcm;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,a,b);</span></span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>) &#123;</span><br><span class="line">		x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	ret=<span class="built_in">exgcd</span>(b,a%b,y,x);</span><br><span class="line">	y-=(a/b)*x;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;LL&gt; S;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(LL t)</span> </span>&#123;</span><br><span class="line">	LL rem=t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x : S) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t&gt;=x)</span><br><span class="line">			rem-=(t-x)/lcm+<span class="number">1</span>;  <span class="comment">//作差周期！ </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rem &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> g,x,y,mod;</span><br><span class="line">	LL t1;</span><br><span class="line">	n=<span class="built_in">mread</span>(),m=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;k);</span><br><span class="line">	<span class="built_in">memset</span>(posa,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(posa));</span><br><span class="line">	<span class="built_in">memset</span>(posb,<span class="number">-1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(posb));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">mread</span>();</span><br><span class="line">		posa[a[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		b[i]=<span class="built_in">mread</span>();</span><br><span class="line">		posb[b[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	g=<span class="built_in">exgcd</span>(n,m,x,y);</span><br><span class="line">	lcm=<span class="number">1ll</span>*n*m/g;</span><br><span class="line">	mod=m/g;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>*<span class="built_in">max</span>(n,m); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(posa[i]!=<span class="number">-1</span> &amp;&amp; posb[i]!=<span class="number">-1</span> &amp;&amp; posa[i]%g==posb[i]%g) &#123;</span><br><span class="line">			t1=<span class="number">1ll</span>*x*(posb[i]-posa[i])/g;</span><br><span class="line">			t1=(t1%mod+mod) %mod;  <span class="comment">//将x1调整到合理的正数</span></span><br><span class="line">			t1=t1*<span class="number">1ll</span>*n + posa[i];</span><br><span class="line">			S.<span class="built_in">push_back</span>(t1);</span><br><span class="line"><span class="comment">//			printf(&quot;%d %d %d %lld\n&quot;,i,posa[i],posb[i],t1);</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(S.<span class="built_in">begin</span>(),S.<span class="built_in">end</span>());</span><br><span class="line">	LL lef=<span class="number">1</span>,rig=<span class="number">1e18</span>,mid,ans;</span><br><span class="line">	<span class="keyword">while</span>(lef&lt;=rig) &#123;</span><br><span class="line">		mid=(lef+rig)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(mid)) &#123;</span><br><span class="line">			ans=mid;</span><br><span class="line">			rig=mid<span class="number">-1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> lef=mid+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>中国剩余定理</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1506G - Maximize the Remaining String</title>
    <url>/2021/08/04/cf1506g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定一个字符串$s$,求将$s$中的重复字符删除，使得剩下的字符串字典序最大。</p>
<script type="math/tex; mode=display">
1 \leq |s| \leq 2\cdot 10^5</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>我们想逐位确定。最初的思路是从’z’到’a’进行贪心。但发现前后顺序并不能有唯一确定的规则。实际上我们还是可以逐位确定的，只是相当于要求，每一次填入一个<strong>有限制条件</strong>的最大字符。所谓的限制条件，就是当这个字符填入后，它后面的字符能够保证将原本答案剩下的不同的字符填上。具体来说，就是假设填完字符$c$后答案串还得填$k$种字符，那么原串$c$的首位置之后的后缀必须有这$k$种字符。</p>
<p>由于总共只有26种字符，所以模拟判定即可。学习一下标程STL的应用。因为数据量并不是很大，所以用<code>string</code>也没问题。此外，<code>reverse</code>方法是可以应用到<code>string</code>和<code>vector</code>的。</p>
<p>关于实现，或者说另一个常见的思路，是用<strong>单调栈</strong>。</p>
<p>我们维护<strong>每个字符在当前的剩余串中的出现次数</strong>，维护一个字典序从（栈底）大到小的单调栈，每次新压入一个字符之前，弹出所有在后面还能出现，且字典序比当前字母小的字母，更新次数。最后把字母从栈底到栈顶输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distin</span><span class="params">(string a)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">unique</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()) - a.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">filt</span><span class="params">(<span class="keyword">const</span> string &amp;s,<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	string t;</span><br><span class="line">	<span class="keyword">bool</span> fir=<span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> now : s) &#123;</span><br><span class="line">		<span class="keyword">if</span>(now!=c &amp;&amp; fir)</span><br><span class="line">			t+=now;  <span class="comment">//验证限制，只有在这个后面的才能加入</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(now==c)</span><br><span class="line">			fir=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">string inp;</span><br><span class="line">set&lt;<span class="keyword">char</span>&gt; hav;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> now;</span><br><span class="line">	<span class="keyword">int</span> kase,k;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;kase);</span><br><span class="line">	<span class="keyword">while</span>(kase--) &#123;</span><br><span class="line">		cin&gt;&gt;inp;</span><br><span class="line">		string ans;</span><br><span class="line">		k=<span class="built_in">distin</span>(inp);</span><br><span class="line">		hav.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> t : inp)hav.<span class="built_in">insert</span>(t);</span><br><span class="line">		<span class="keyword">while</span>(k) &#123;</span><br><span class="line">			now=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x : hav)</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">distin</span>(<span class="built_in">filt</span>(inp,x)) == k<span class="number">-1</span>)</span><br><span class="line">					now=<span class="built_in">max</span>(now,x);</span><br><span class="line">			ans+=now;</span><br><span class="line">			hav.<span class="built_in">erase</span>(now);</span><br><span class="line">			inp=<span class="built_in">filt</span>(inp,now);</span><br><span class="line">			k--;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>逐位考虑</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 B</title>
    <url>/2021/07/27/2021Nowcoder4A/</url>
    <content><![CDATA[<h2 id="A-Course"><a href="#A-Course" class="headerlink" title="A Course"></a>A Course</h2><p><strong>生成函数</strong>来计数不同课的选择方案</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n x^i = \frac{1}{1-x^n}\\
f_i(x) =\prod_{i \to j}  f_j...</script><h2 id="B-Sample-Game"><a href="#B-Sample-Game" class="headerlink" title="B Sample Game"></a>B Sample Game</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>有一个随机数生成器可以生成$[1,n]$中所有数，每个数被生成的概率为$p_i$,该生成器如果生成的数均不小于之前生成的所有数，则继续生成，否则停止。记每一轮一共生成了$x$个数，则收益为$x^2$。问期望收益。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">
1 \leq n \leq 100</script><h3 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h3><p>这个题巧妙之处在于对长度发生概率的<strong>设而不求</strong>。</p>
<p>首先我们根据题意知道除了最后一个数之外，该生成序列是单调不降的。那么一旦我们知道了每一个数被生成了多少次，则生成序列唯一确定。因此我们可以用<strong>生成函数</strong>来描述这个期望。</p>
<p>注意到对于一种数，它的被生成的无限期望为</p>
<script type="math/tex; mode=display">
E(\infty)=\sum_{i=1}^{\infty}p_s^i \cdot x_s^i=\frac{1}{1-p_sx_s}</script><p>因此从<strong>序列长度</strong>为1到长度为无穷的期望组合的描述如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=\sum_{i=1}^{\infty} \big(\sum_{s_1+s_2+...+s_n=i} \prod_{k=1}^n p_k^{s_k}) \cdot x^i\\
&=\sum_{i=1}^{\infty}P(len>i)x^i\\
&=\prod_{i=1}^n (1+p_ix_i+p_i^2x_i^2+...+p_i^{\infty}x_i^{\infty})\\
&=\prod_{i=1}^n \frac{1}{1-p_ix}
\end{aligned}</script><p>但这个描述的目的只是间接的得到概率的关系，我们还是得考虑具体的期望公式，再设法往上面得到的这个$f(x)$上转化。</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=\sum_{i=0}^{\infty}\big(P(len>i) -P(len>i+1))\cdot i^2\\
&展开后按照P(len>i)合并项得到\\
&=\sum_{i=0}^{\infty}P(len>i)[(i+1)^2-i^2]\\
&=\sum_{i=0}^{\infty}P(len>i)(2i+1)\\
&=2\cdot f'(1)+f(1)
\end{aligned}</script><p>下面再考虑求$f’(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
令g_i(x)&=\frac{1}{1-p_ix}\\
则g_i'(x)&=\frac{p_i}{(1-p_ix)^2}\\
故f'(x)&=\sum_{i=1}^{n}g_i'(x)\cdot \prod_{j \not=i}g_j(x)\\
&=f(x)\cdot \sum_{i=1}^n \frac{p_i}{1-p_ix}
\end{aligned}</script><p>故答案就是</p>
<script type="math/tex; mode=display">
\big(1+2\cdot\sum_{i=1}^n \frac{p_i}{1-p_i})f(1)</script>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>概率期望</tag>
        <tag>设而不求</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1508A - Binary Literature</title>
    <url>/2021/08/04/cf1508a/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有三个长度为$2n$的01串，现在要求构造一个长度不超过$3n$的01串，使得所给的三个01串中至少两个是该构造串的子序列。</p>
<script type="math/tex; mode=display">
1  \leq n \leq 10^5</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题的关键在于<strong>怎么处理3和2的关系</strong>。</p>
<p>一个正确的思路是尽量用串与串之间公共的子序列来节省构造的位置。一个错误的方向是从三个串两两考虑来验证能否构造。</p>
<p>为什么是错误的方向？如果是这么做，为什么是给三个串而不是四个、五个串？为什么最后构造长度要求$3n$不是其他量？</p>
<p>这个3是有原因的。</p>
<p>首先说一说证明上的可行性。</p>
<p>根据抽屉原理，长度为$2n$的01串，至少有一种数码出现不少于$n$​​次。而<strong>再根据抽屉原理</strong>，三个串的这种数码必然有两个串的是一样的。</p>
<p>也就是说，最终的串必然有$00…0$或$11…1$的子序列，长度至少为$n$.而包含两个串作为子序列的答案串长度$L \leq |s|+|t|-lcs \leq4n-n=3n$​因此构造是一定可行的。</p>
<p>再说具体的构造方法。其实还是抽屉原理。</p>
<p>我们不妨用三个指针来考虑三个给定的01串。那么这三个指针指向的字符，必然有一个是在两个串上都出现的（因为只有01两种字符），把它放到答案中，移动指针。那么一直移动下去必然有一个时刻某个串全部包含在了答案中。记此时答案串已有字符$k$个，这说明三个指针至少移动了$2k$次，那么对于剩下两个没有完全包含的01串，已经移动了$2k-2n$次，<strong>再利用抽屉原理</strong>，必然有一个串的指针至少移动了$k-n$次。现在把这个串的剩余部分全放到答案中。这么做之所以可行，是因为$2n-(k-n)=3n-k$​.</p>
<p>P.S. 这种抽屉原理套抽屉原理让我回想起当年高三做北京高考数学最后一题的情形。（归根结底还是不会呀（逃））</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="keyword">char</span> a[MAXN&lt;&lt;<span class="number">1</span>],b[MAXN&lt;&lt;<span class="number">1</span>],c[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">char</span> output[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sig;</span><br><span class="line">	<span class="keyword">int</span> kase;</span><br><span class="line">	kase=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">int</span> i,j,k,now;</span><br><span class="line">	<span class="keyword">while</span>(kase--) &#123;</span><br><span class="line">		n=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,a+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,b+<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c+<span class="number">1</span>);</span><br><span class="line">		now=i=j=k=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;=<span class="number">2</span>*n &amp;&amp; j&lt;=<span class="number">2</span>*n &amp;&amp; k&lt;=<span class="number">2</span>*n) &#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i]==b[j]) &#123;</span><br><span class="line">				output[now++]=a[i];</span><br><span class="line">				i++,j++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i]==c[k]) &#123;</span><br><span class="line">				output[now++]=a[i];</span><br><span class="line">				i++,k++;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(b[j]==c[k]) &#123;</span><br><span class="line">				output[now++]=b[j];</span><br><span class="line">				j++,k++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;<span class="number">2</span>*n) &#123;</span><br><span class="line">				sig=<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;<span class="number">2</span>*n) &#123;</span><br><span class="line">				sig=<span class="number">2</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(k&gt;<span class="number">2</span>*n) &#123;</span><br><span class="line">				sig=<span class="number">3</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//			printf(&quot;%d %d %d\n&quot;,i,j,k);</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">		<span class="keyword">if</span>(sig==<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(j&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=b[j++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(k&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=c[k++];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(sig==<span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(i&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(k&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(k&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=c[k++];</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(sig==<span class="number">3</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(i&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=a[i++];</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(j&gt;=now-n)</span><br><span class="line">				<span class="keyword">while</span>(j&lt;=<span class="number">2</span>*n)</span><br><span class="line">					output[now++]=b[j++];</span><br><span class="line">		&#125;</span><br><span class="line">		output[now]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,output+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>组合数学</tag>
        <tag>抽屉原理</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 736 (Div. 2) E - The Three Little Pigs</title>
    <url>/2021/08/03/cf1549e/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>对于一个$n$,给定$q$​​次询问,回答</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{n}C_{3i}^{x}</script><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 10^6\\
1 \leq q \leq 10^6</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题主要考察组合恒等式的运用，或者用生成函数的方法。</p>
<h3 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h3><p>我们首先肯定有两个组合恒等式</p>
<script type="math/tex; mode=display">
C_{n}^m=C_{n-1}^m+C_{n-1}^{m-1}\\
\sum_{k=r}^{n}C_{k}^r=C_{n+1}^{r+1}</script><p>其中第二个式子可以用数学归纳法结合第一个式子证明。</p>
<p>因此针对本题3的倍数这一特点，我们考虑通过剩余类来DP</p>
<p>定义</p>
<script type="math/tex; mode=display">
dp[x][m]=\sum_{i=0}^{n-1}C_{3i+m}^x</script><p>则我们有递推式</p>
<script type="math/tex; mode=display">
dp[x][0]+dp[x][1]+dp[x][2]=\sum_{i=0}^{3n-1}C_{i}^{x}=C_{3n}^{x+1}\\
dp[x][1]=dp[x][0]+dp[x-1][0]\\
dp[x][2]=dp[x][1]+dp[x-1][1]\\</script><p>求解这三个方程并递推便能预处理得到所有的情况。</p>
<p>最t后答案便是</p>
<script type="math/tex; mode=display">
ans[x]=dp[x][0]+C_{3n}^x</script><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 3001000</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line">LL fac[MAXN],inv[MAXN];</span><br><span class="line">LL dp[MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">Combo</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span> || m&lt;<span class="number">0</span> || n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> fac[n]*inv[m]%MOD*inv[n-m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	LL div3=<span class="built_in">quick_pow</span>(<span class="number">3</span>,MOD<span class="number">-2</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">	fac[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>*n; i++)fac[i]=<span class="number">1ll</span>*i*fac[i<span class="number">-1</span>]%MOD;</span><br><span class="line">	<span class="comment">//加速方法 </span></span><br><span class="line">	inv[<span class="number">3</span>*n]=<span class="built_in">quick_pow</span>(fac[<span class="number">3</span>*n],MOD<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>*n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)inv[i]=inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>]=dp[<span class="number">0</span>][<span class="number">1</span>]=dp[<span class="number">0</span>][<span class="number">2</span>]=n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>*n; i++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>]=(<span class="built_in">Combo</span>(<span class="number">3</span>*n,i+<span class="number">1</span>)<span class="number">-1ll</span>*<span class="number">2</span>*dp[i<span class="number">-1</span>][<span class="number">0</span>]%MOD-dp[i<span class="number">-1</span>][<span class="number">1</span>]+<span class="number">1ll</span>*<span class="number">3</span>*MOD)*div3%MOD;</span><br><span class="line">		dp[i][<span class="number">1</span>]=(dp[i][<span class="number">0</span>]+dp[i<span class="number">-1</span>][<span class="number">0</span>]+MOD)%MOD;</span><br><span class="line">		dp[i][<span class="number">2</span>]=(dp[i][<span class="number">1</span>]+dp[i<span class="number">-1</span>][<span class="number">1</span>]+MOD)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(dp[x][<span class="number">0</span>]+<span class="built_in">Combo</span>(<span class="number">3</span>*n,x)+MOD)%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p>这道题求解时的瓶颈就是组合数如何生成？除了上面解法1通过组合恒等式来DP外，我们可以结合<strong>二项式定理</strong>和<strong>生成函数</strong>的思路。</p>
<p>考虑</p>
<script type="math/tex; mode=display">
P(t)=(1+t)^3+(1+t)^6+...+(1+t)^{3n}</script><p>该幂级数展开后，$t^x$​的系数就是我们所求的答案。所以我们可以计算这个级数的系数表示，即可。</p>
<script type="math/tex; mode=display">
P(t)=\frac{(1+t)^{3n+3}-(1+t)^3}{(1+t)^3-1}</script><p>这个式子模拟大除法即可。由于分母很容易得到系数，分子通过组合数预处理，所以线性就可以求出所有系数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cancel k from numerator and denominator of P(k)</span></span><br><span class="line">   <span class="function">vl <span class="title">num</span><span class="params">(M,<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="built_in">REP</span>(i,M) &#123;</span><br><span class="line">       num[i] = c.<span class="built_in">choose</span>(M,i+<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span> (i &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">           num[i] -= c.<span class="built_in">choose</span>(<span class="number">3</span>,i+<span class="number">1</span>);</span><br><span class="line">           num[i] = (num[i]+MOD)%MOD;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//denominator is k^2+3k+3</span></span><br><span class="line">   <span class="comment">//P(k) is num/denominator</span></span><br><span class="line"></span><br><span class="line">   <span class="function">vl <span class="title">P</span><span class="params">(<span class="number">3</span>*N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>*N; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">       P[i] = num[i+<span class="number">2</span>];</span><br><span class="line">       num[i+<span class="number">1</span>] = (num[i+<span class="number">1</span>]<span class="number">-3</span>*P[i]+<span class="number">3</span>*MOD)%MOD;</span><br><span class="line">       num[i] = (num[i]<span class="number">-3</span>*P[i]+<span class="number">3</span>*MOD)%MOD;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>组合数学</tag>
        <tag>递推与动归</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces 1549D - Integers Have Friends</title>
    <url>/2021/08/02/cf1549d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>Define a <strong>subarray</strong> $a_i,a_{i+1},…,a_j$​​​ to be a <em>friend group</em> if and only if there exists an integer $m≥2$​ such that $a_i\; mod\;m=a_{i+1}\;mod\;m=…=a_j\;mod\;m$​,</p>
<p>Your friend Gregor wants to know the size of the <strong>largest</strong> friend group in $a$.</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
\sum n \leq 2 \cdot 10^5</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题没做出来真是太可惜了！其实就是<strong>求一个序列最长的GCD区间</strong>，基本的想法都想到了，却栽在这个数据结构的处理上。</p>
<p>核心问题：双指针。</p>
<p>区间GCD和区间max，区间min都是符合叠加原则的，因此它的单调性就在于如果我的区间范围越大，那么区间GCD趋向于更小。因此我们只需要有ST表来$O(logn)$预处理，$O(1)$询问来验证一个区间的GCD，然后固定右端点，不断地跳左端点来更新最大区间就行了！</p>
<p>复杂度 $O(Nlog1e18logn)$</p>
<p>注意ST表怎么来$O(1)$查询的！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200100 </span></span><br><span class="line"><span class="function">LL <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL a[MAXN],d[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> ST &#123;</span><br><span class="line">	LL st[MAXN][<span class="number">22</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)st[i][<span class="number">0</span>]=d[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=<span class="number">22</span>; j++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i+(<span class="number">1</span>&lt;&lt;j)<span class="number">-1</span>&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">				st[i][j]=<span class="built_in">gcd</span>(st[i][j<span class="number">-1</span>],st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		LL ret=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> h=<span class="built_in">floor</span>(<span class="built_in">log2</span>(r-l+<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">gcd</span>(st[l][h],st[r-(<span class="number">1</span>&lt;&lt;h)+<span class="number">1</span>][h]);<span class="comment">//ST表的运用最大覆盖即可 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kase;</span><br><span class="line">	<span class="keyword">int</span> ans,j;</span><br><span class="line">	kase=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">while</span>(kase--) &#123;</span><br><span class="line">		n=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)d[i]=<span class="built_in">abs</span>(a[i+<span class="number">1</span>]-a[i]);</span><br><span class="line">		ST::<span class="built_in">build</span>();</span><br><span class="line">		j=<span class="number">1</span>,ans=<span class="number">1</span>;<span class="comment">//初始化！ </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">while</span>(j&lt;=i &amp;&amp; ST::<span class="built_in">query</span>(j,i) == <span class="number">1</span>)j++;</span><br><span class="line">			ans=<span class="built_in">max</span>(ans,i-j+<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC, Central Europe Regional Contest (CERC 16) H - Hangar Hurdles</title>
    <url>/2021/08/06/gym101173h/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给一个由<code>.</code>和<code>#</code>组成的地图。现在要回答若干询问,从$(x_1,y_1)$​到$(x_2,y_2)$能够滑动的最大正方形的边长为多少。所谓能滑动就是路经的各个方格所能扩展的不碰到<code>#</code>的最大正方形。</p>
<script type="math/tex; mode=display">
1 \leq n \leq 1000\\
1 \leq q \leq 3 \cdot 10^5</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>先说说考场上那种看起来很多，但种种原因不能通过的解法。</p>
<p>首先我们可以预处理出每个点能够允许的最大正方形。这里先说一下还是应该枚举半边长以保证正方形边长是奇数。然后我们把所有的节点从大到小依次加入到图中，用并查集来维护联通关系。把所有的询问离线，然后取询问的两个点的对应最大正方形边长的较小值来排序，从大到小回答询问。然后从大到小遍历边长，处理询问。如果某个询问不能在它对应的较小值时被处理，就把它放到一个队列里。这个队列也不断地取队首尝试回答询问。最后再按照原顺序输出即可。</p>
<p>这个解法的RE原因只不过是局部变量没赋初值，但WA之后就很难调了。理论上分析它的漏洞在于可能一些询问会反反复复出入队列，造成时间的问题。</p>
<p>下面来说正解。</p>
<p>其实基本要点已经体现了。就是我们要<strong>控制节点之间的连通性，是从大到小的添加边</strong>。而这正是我们<strong>用Kruskal做一棵最大生成树</strong>的流程。所以我们把每个点向四周能连边的连边，边的权值就是两个点最大正方形边长的最小值，然后跑一下Kruskal得到生成树。那么处理询问，就是看这个重构树上对应路径的最小边权值。求这个东西就很经典，相当于边倍增找LCA，边更新答案。</p>
<p>由于<strong>可能有许多的树（森林）</strong>，所以树链剖分+LCA就不适用了，还是得用倍增。</p>
<p>具体细节见代码。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a) &gt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> s[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> sum[MAXN][MAXN],mmax[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x&lt;<span class="number">1</span> || x&gt;n || y&lt;<span class="number">1</span> || y&gt;n || s[x][y]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">	x2=x+t<span class="number">-1</span>,y2=y+t<span class="number">-1</span>;</span><br><span class="line">	x1=x-t+<span class="number">1</span>,y1=y-t+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">check2</span>(x1,y1) || !<span class="built_in">check2</span>(x2,y2))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> (sum[x2][y2] - sum[x2][y1<span class="number">-1</span>] - sum[x1<span class="number">-1</span>][y2] + sum[x1<span class="number">-1</span>][y1<span class="number">-1</span>]==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN2 1001000</span></span><br><span class="line"><span class="keyword">namespace</span> Tree &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> v,len;</span><br><span class="line">		node *nnext;</span><br><span class="line">	&#125; pool[MAXN2&lt;&lt;<span class="number">2</span>],*h[MAXN2&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		node *p=&amp;pool[++cnt];</span><br><span class="line">		p-&gt;v=v,p-&gt;len=len,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">		node *q=&amp;pool[++cnt];</span><br><span class="line">		q-&gt;v=u,q-&gt;len=len,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> f[MAXN2][<span class="number">21</span>],anc[MAXN2][<span class="number">21</span>];</span><br><span class="line">	<span class="keyword">int</span> dep[MAXN2];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> v,mid;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">20</span>; i++) &#123;</span><br><span class="line">			mid=anc[u][i<span class="number">-1</span>];</span><br><span class="line">			anc[u][i]=anc[mid][i<span class="number">-1</span>];</span><br><span class="line">			f[u][i]=<span class="built_in">min</span>(f[u][i<span class="number">-1</span>],f[mid][i<span class="number">-1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">			v=p-&gt;v;</span><br><span class="line">			<span class="keyword">if</span>(v!=fa) &#123;</span><br><span class="line">				dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line">				f[v][<span class="number">0</span>]=p-&gt;len;</span><br><span class="line">				anc[v][<span class="number">0</span>]=u;</span><br><span class="line">				<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">		<span class="keyword">if</span>(dep[x] &lt; dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--) <span class="comment">//跳到同一起点</span></span><br><span class="line">			<span class="keyword">if</span>(dep[anc[x][i]] &gt;= dep[y]) &#123;  <span class="comment">//!等号</span></span><br><span class="line">				ans=<span class="built_in">min</span>(ans,f[x][i]);</span><br><span class="line">				x=anc[x][i];</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="keyword">if</span>(x==y) <span class="keyword">return</span> ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">			<span class="keyword">if</span>(anc[x][i]!=anc[y][i]) &#123;</span><br><span class="line">				ans=<span class="built_in">min</span>(ans,f[x][i]);</span><br><span class="line">				ans=<span class="built_in">min</span>(ans,f[y][i]);</span><br><span class="line">				x=anc[x][i];</span><br><span class="line">				y=anc[y][i];</span><br><span class="line">			&#125;</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[x][<span class="number">0</span>]);</span><br><span class="line">		ans=<span class="built_in">min</span>(ans,f[y][<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Kru &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> u,v,len;</span><br><span class="line">	&#125; e[MAXN2&lt;&lt;<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> ecnt;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.len &gt; b.len;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> p[MAXN2];</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">ffind</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(p[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">		<span class="keyword">return</span> p[x]=<span class="built_in">ffind</span>(p[x]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> fx,fy;</span><br><span class="line">		<span class="built_in">sort</span>(e+<span class="number">1</span>,e+ecnt+<span class="number">1</span>,cmp);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">				p[(i<span class="number">-1</span>)*n+j]=(i<span class="number">-1</span>)*n+j;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=ecnt; i++) &#123;</span><br><span class="line">			fx=<span class="built_in">ffind</span>(e[i].u),fy=<span class="built_in">ffind</span>(e[i].v);</span><br><span class="line">			<span class="keyword">if</span>(fx!=fy) &#123;</span><br><span class="line">				p[fy]=fx;</span><br><span class="line">				Tree::<span class="built_in">addedge</span>(e[i].u,e[i].v,e[i].len);  <span class="comment">//并不能用并查集的标号来</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> lef,rig,mid;  <span class="comment">//局部变量的初始化？</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			sum[i][j]=sum[i][j<span class="number">-1</span>]+((s[i][j]==<span class="string">&#x27;#&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">			sum[i][j]+=sum[i<span class="number">-1</span>][j];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			lef=<span class="number">1</span>,rig=n;</span><br><span class="line">			<span class="keyword">while</span>(lef&lt;=rig) &#123;</span><br><span class="line">				mid=(lef+rig)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check</span>(i,j,mid)) &#123;</span><br><span class="line">					mmax[i][j]=<span class="built_in">max</span>(mmax[i][j],<span class="number">2</span>*(mid<span class="number">-1</span>)+<span class="number">1</span>);</span><br><span class="line">					lef=mid+<span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> rig=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">2</span>]= &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">2</span>]= &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;<span class="number">2</span>; l++) &#123;</span><br><span class="line">				nx=i+dx[l],ny=j+dy[l];</span><br><span class="line">				<span class="keyword">if</span>(<span class="built_in">check2</span>(nx,ny))</span><br><span class="line">					Kru::e[++Kru::ecnt]= &#123;(i<span class="number">-1</span>)*n+j,(nx<span class="number">-1</span>)*n+ny,<span class="built_in">min</span>(mmax[i][j],mmax[nx][ny])&#125;;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	Kru::<span class="built_in">kruskal</span>();</span><br><span class="line">	<span class="built_in">memset</span>(Tree::f[<span class="number">0</span>],<span class="number">63</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Tree::f[<span class="number">0</span>]));<span class="comment">//!</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="comment">//仍应该考虑森林情况 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(s[i][j]==<span class="string">&#x27;#&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(!Tree::dep[(i<span class="number">-1</span>)*n+j])</span><br><span class="line">			&#123;</span><br><span class="line">				Tree::dep[(i<span class="number">-1</span>)*n+j]=<span class="number">1</span>;</span><br><span class="line">				Tree::<span class="built_in">dfs</span>((i<span class="number">-1</span>)*n+j,<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">int</span> q,x1,y1,x2,y2;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">		<span class="keyword">if</span>(Kru::<span class="built_in">ffind</span>((x1<span class="number">-1</span>)*n+y1)!=Kru::<span class="built_in">ffind</span>((x2<span class="number">-1</span>)*n+y2))<span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,Tree::<span class="built_in">get_ans</span>((x1<span class="number">-1</span>)*n+y1,(x2<span class="number">-1</span>)*n+y2));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>并查集重构树</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) D Contest Strategy</title>
    <url>/2021/07/30/gym101201d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>你正在参加一场ACM比赛。已知自己每个题解决的用时。现在你随机开了$k$道题，然后找用时最短的做了，然后再随机开一道，再选用时最短的做了。现在考虑所有开题顺序$n!$中可能，求所有情况的罚时总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq k<n\leq 300</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题求解真是<strong>构造和分析小数据</strong>起了很大的作用。“随机”并不可怕，只要把情况都考虑全了就没有问题。</p>
<p>首先说一些简单的性质。就是我们可以记$f[i][j]$​表示第i个题是第j个做的（注意不是开是做！）。那么很显然可以给答案贡献$f[i][j] \cdot t[i]\cdot(n-j+1)$。所以问题转化为怎么求解$f[i][j]$.</p>
<p>我们不妨看几个例子。令$k=5$​比如下面几个状态的4号题（用时也是4个单位时间）前两个第4个做的，第三组是第3个做的：</p>
<script type="math/tex; mode=display">
\text{1 2 8 9 10} \; \underline{4} \;\text{3 5}\\
\text{1} \; \underline{4} \;\text{8 9 10 2 3 5}\\
\text{6 7 8 9 10 5} \; \underline{4} \; 3</script><p>我们从中发现几件事：</p>
<p>为了方便，我们把题目按照解决用时从小到大排序。</p>
<p>首先，如果$i$号题是第$j$个做的，那么到这个题做的时候，已经开了$k-1+j$​个题。而且当这个题做的时候，此时<strong>开了且没做</strong>的题目一定是用时比这个题长的。</p>
<p>令$r=min(k-i+j,n)$​表示已经开了的题数目，$l$为已经开了的题目中用时比这个题短的。</p>
<p>因此$f[i][j]$​一定包含乘积项$A_{n-i}^{r-1-l}$</p>
<p>那么回到上面举的例子，很有可能某个题先开了，但是过了几轮才做，这是因为一直存在比它用时小的题目。所以我们要在计数中枚举比它用时短的题目及其排列，所以$f[i][j]$包含乘积项$A_{i-1}^{l}$</p>
<p>由于题目要求<strong>开题都是有序</strong>的（$n!$​​种情况），因此我们枚举这道题是什么时候开的，以及<strong>比他用时短的题目</strong>都分别是什么时候开的，因此答案会有乘积项$r \cdot C_{r-1}^{l}$</p>
<p>最后我们再考虑这个题目解决后剩下题目的解决顺序，有乘积项$(n-r)!$</p>
<p>这样我们就得到</p>
<p>$f[i][j]=\sum_{l=0}^{j}r\cdot C_{r-1}^{l} \cdot A_{i-1}^{l}\cdot A_{n-i}^{r-1-l} \cdot(n-r)!$</p>
<p>但是我们立刻会发现问题，就是在枚举这个题开题和比他用时短的题目开题顺序时其实并不能这样直接用组合数算，因为这样有些情况导致$i$号题<strong>提前做了</strong>。但是我们发现这样的枚举，总是可以保证$i$号题是前$j$个被解决的题。因此我们修改$f[i][j]$​的含义是<em>第i个题是前j个做的</em>，最后再容斥一下用$f[i][j]-f[i][j-1]$去贡献答案即可。</p>
<p>复杂度为$O(n^3)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">mread</span></span>() &#123;</span><br><span class="line">	int ret=0,f=1;</span><br><span class="line">	char c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=-1;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*10+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="built_in">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL combo[330][330];</span><br><span class="line">LL t[330],ans=0;</span><br><span class="line">int n,k;</span><br><span class="line">const int MOD=1e9+7;</span><br><span class="line">LL CC(int n,int m) &#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;0 || n&lt;m || m&lt;0)<span class="built_in">return</span> 0;</span><br><span class="line">	<span class="built_in">return</span> combo[n][m];</span><br><span class="line">&#125;</span><br><span class="line">LL f[330][330];</span><br><span class="line">LL fac[330];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	int r;</span><br><span class="line">	LL tmp,cnt;</span><br><span class="line">	n=mread(),k=mread();</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)t[i]=mread();</span><br><span class="line">	sort(t+1,t+n+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=0; i&lt;=n; i++)combo[i][0]=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++)</span><br><span class="line">			combo[i][j]=(combo[i-1][j]+combo[i-1][j-1])%MOD;</span><br><span class="line">	fac[0]=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)fac[i]=1ll*fac[i-1]*i%MOD;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++) &#123;</span><br><span class="line">			r=min(j+k-1,n);</span><br><span class="line">			<span class="keyword">for</span>(int l=0; l&lt;j; l++) &#123;</span><br><span class="line">				f[i][j]=(f[i][j]+1ll*r*CC(i-1,l)%MOD*CC(r-1,l)%MOD*fac[l]%MOD*CC(n-i,r-1-l)%MOD</span><br><span class="line">				         *fac[r-1-l]%MOD*fac[n-r]%MOD+MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt=f[i][j]-f[i][j-1]+MOD;</span><br><span class="line">			ans=(ans+1ll*t[i]*(n-j+1)%MOD*cnt%MOD+MOD)%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>注意题目用时可能一样，但实际上是不同的题目。这里确实是在$A_{i-1}^l$步有问题，但是可以通过容斥来弥补。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1)  G - Maximum Islands</title>
    <url>/2021/07/30/gym101201g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给一张表格，表格上<code>L</code>代表陆地，<code>W</code>代表水域,<code>C</code>代表未知（可以使陆地也可以使水域）。现在可以将C区域变成陆地或水域，问最多陆地的连通块有多少块？</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m\leq 40</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先贪心上应该把L周围的区域变成水域，然后再考虑剩下的C点。我们希望尽可能多的填上L，因此最好相邻的格子填不同的区域。</p>
<p>所以问题就转化成一个二分图求最大独立集的问题（见下文）。考虑将原表格从上到下从左到右黑白染色划分格子的归属（说白了就是行号和列号奇偶性相同为黑色，不同为白色），然后对于C点相邻连边，跑最大匹配即可。</p>
<p>最后答案就是原本贪心后已有的L连通块个数 + C点数 - 最大匹配数。</p>
<h2 id="图论相关概念回顾"><a href="#图论相关概念回顾" class="headerlink" title="图论相关概念回顾"></a>图论相关概念回顾</h2><p><code>独立集</code>：无向图点集的一个子集，其中<strong>任意两点不相连</strong>。</p>
<p><code>匹配</code>：无向图边的一个子集，该子集<strong>任意两条边没有公共顶点</strong>且没有自环 </p>
<p><code>顶点覆盖</code>：无向图点集的子集，使得边集中任意一条边都至少有一个点在该子集中。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>|最小顶点覆盖| + |最大独立集| = |V|</p>
<p>在<strong>二分图</strong>中，最小顶点覆盖 = 最大匹配，因此最大独立集 = 点数 - 最大匹配数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,u,v);</span></span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>]= &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&lt;=x &amp;&amp; x&lt;=n &amp;&amp; <span class="number">1</span>&lt;=y &amp;&amp; y&lt;=m)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">			<span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; lef,rig;</span><br><span class="line"><span class="keyword">int</span> connect[<span class="number">2000</span>],state[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(state[v]==<span class="number">0</span>) &#123;</span><br><span class="line">			state[v]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(connect[v]==<span class="number">0</span> || <span class="built_in">match</span>(connect[v])) &#123;</span><br><span class="line">				connect[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> now : lef) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(state,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(state));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">match</span>(now))</span><br><span class="line">			sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	n=<span class="built_in">mread</span>(),m=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">					nx=i+dx[k],ny=j+dy[k];</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny) &amp;&amp; mp[nx][ny]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">						mp[nx][ny]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)printf(&quot;%s\n&quot;,mp[i]+1);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;L&#x27;</span> &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="built_in">dfs</span>(i,j);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]!=<span class="string">&#x27;C&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">if</span>((i^j) &amp; <span class="number">1</span>)lef.<span class="built_in">push_back</span>((i<span class="number">-1</span>)*m+j);</span><br><span class="line">			<span class="keyword">else</span> rig.<span class="built_in">push_back</span>((i<span class="number">-1</span>)*m+j);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i,j+<span class="number">1</span>) &amp;&amp; mp[i][j+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">				<span class="built_in">addedge</span>((i<span class="number">-1</span>)*m+j,(i<span class="number">-1</span>)*m+j+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i+<span class="number">1</span>,j) &amp;&amp; mp[i+<span class="number">1</span>][j]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">				<span class="built_in">addedge</span>((i<span class="number">-1</span>)*m+j,i*m+j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(auto x : lef)printf(&quot;%d &quot;,x);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//	for(auto x : rig)printf(&quot;%d &quot;,x);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans-<span class="built_in">hungary</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) J - Shopping</title>
    <url>/2021/07/30/gym101201j/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>$n$个数的数列 $a_n$​ ,$q$次询问。</p>
<p>每次询问给出数$v$，区间端点$[l，r]$,问用$v$按顺序依次对数列$[l,r]$中的数取模，得到的最终答案。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,q \leq 2 \cdot 10^5\\
1 \leq a_i,v \leq 10^{18}</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这道题在考场上试图通过主席树+二分来解，可惜复杂度为$O(qlog^21e18log^2n)$常数大得离谱。故失败。</p>
<p>首先我们注意到一点，就是每一次取模，这个$v$都会减小一半，因此直接取模最多$log1e18$​求解是可行的。关键在于每次精确的找到对哪个数取模？实际上，就是求对于当前这个数，在它右边最近的小于等于它的数的位置。</p>
<p>这里之前用主席树做麻烦了，其实把上面这句话<strong>翻译</strong>下，不就是<strong>该数$x$向右延伸最多能延伸多少遇到的都是$&gt;x$​​的数</strong>？这件事就转化为一个区间最小值的问题了。而且为了更好的解决延伸，其实用ST表和倍增思路就一步到位了。</p>
<p>实现见代码。</p>
<p>复杂度为$O(qlogn \cdot log10^{18})$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200100</span></span><br><span class="line">LL mmin[MAXN][<span class="number">25</span>];</span><br><span class="line">LL a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL v;</span><br><span class="line">	<span class="keyword">int</span> l,r,now;</span><br><span class="line">	n=<span class="built_in">mread</span>(),q=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">mread</span>();</span><br><span class="line">		mmin[i][<span class="number">0</span>]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">25</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=n; j++)</span><br><span class="line">			mmin[j][i]=<span class="built_in">min</span>(mmin[j][i<span class="number">-1</span>],mmin[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		v=<span class="built_in">mread</span>(),l=<span class="built_in">mread</span>(),r=<span class="built_in">mread</span>();</span><br><span class="line">		now=l;</span><br><span class="line">		<span class="keyword">while</span>(now&lt;=r) &#123;</span><br><span class="line">			v=v%a[now];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">				<span class="keyword">if</span>(now+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=r &amp;&amp; mmin[now][i]&gt;v)</span><br><span class="line">					now+=((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>);<span class="comment">//应落到可控范围内</span></span><br><span class="line">			now++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>ST表</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 Pacific Northwest Region Programming Contest—Division 1 K Tournament Wins</title>
    <url>/2021/07/30/gym101201k/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>某人参加一场淘汰赛，实力排名为$r$，排名越高实力越强。一共有$2^k$支队伍参加比赛，问这个人获胜场次的概率。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq k \leq 20 \\
1 \leq r \leq 2^k</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这题还是一个要画画图，不能干想。其实把那张满二叉树的晋级图画出来，就明白是怎么回事了。</p>
<p>其实从图上显然看出，某人如果要至少赢$i$​​​场，则应该战胜$2^i-1$个对手。这其实和线段树求区间最小值的原理是类似的。因此可以得到概率</p>
<script type="math/tex; mode=display">
s[i]=\frac{C_{2^k-r}^{2^i-1}}{C_{2^k-1}^{2^i-1}}</script><p>设$f(i)$表示恰好赢$i$场的概率，那么答案</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=1\cdot f(1) + 2\cdot f(2)+...n\cdot f(n)\\
&=s[1]+s[2]+...+s[n]
\end{aligned}</script><p>这里值得一提的是怎么快速计算$s[i]$，答案是取对数。</p>
<p>即</p>
<script type="math/tex; mode=display">
s[i]=e^{ln(C_{2^k-1}^{2^i-1})-ln(C_{2^k-r}^{2^i-1})}\\</script><p>而</p>
<script type="math/tex; mode=display">
ln(x!)=ln((x-1)!)+ln(x)</script><p>因此只要预处理即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">double</span> my_pow[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lnc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_pow[n] - my_pow[m] - my_pow[n-m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,now;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0.0</span>;</span><br><span class="line">	k=<span class="built_in">mread</span>(),r=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(<span class="number">1</span>&lt;&lt;k); i++)my_pow[i]=my_pow[i<span class="number">-1</span>]+<span class="built_in">log</span>((<span class="keyword">double</span>)<span class="number">1.0</span>*i);</span><br><span class="line">	n=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		now=(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n-r &lt; now)<span class="keyword">continue</span>;</span><br><span class="line">		s[i]=<span class="built_in">exp</span>(<span class="built_in">lnc</span>(n - r,now) - <span class="built_in">lnc</span>(n - <span class="number">1</span>,now));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">		ans+=s[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大权匹配KM算法介绍</title>
    <url>/2021/08/01/km/</url>
    <content><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p><code>完备匹配</code> ： X点集所有的点都参与了匹配。</p>
<p><code>可行边</code> ： $lx[i]+ly[j] \geq w[i][j]$的边</p>
<p><code>相等子图</code> ：包含所有点和<strong>可行边</strong>的子图。</p>
<p><code>顶标</code> ： $lx[i],ly[j]$​,人为赋值的点权，为了控制可行边而设立。</p>
<p><code>松弛量</code> ：$\forall i \in Y,slack[y]=min(lx[x]+ly[i]-w[x][i])$</p>
<p><code>顶标修改量</code> ： $d=min(slack[y])$</p>
<p>需要注意的是，松弛量和顶标修改量都是针对当前没有被匹配的Y部的点来操作的。</p>
<h1 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>给X、Y两部点的顶标进行贪心地赋值，然后修改顶标值使得更多的边成为可行边，扩大相等子图，从而增加匹配，直到相等子图达到完备匹配。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>①初始化设定$lx[i]=max_{i \to j}(w[i][j])$,$ly[i]=0$</p>
<p>②对每个X部的点，<strong>尝试增加匹配</strong>。更新Y部点的松弛量，并求得顶标修改量。记录下最终贡献顶标修改量的<strong>Y部节点</strong>，即为本次增广的匹配点。为了降低复杂度，需要<strong>记录改善匹配的路径</strong>（用前向星）。所以调整完所有的松弛量和顶标修改后，更新匹配状态。</p>
<p>③答案就是Y部每个点与对应X部匹配点之间连边权值之和</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^3)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注：这份代码适用于处理X、Y部节点数相等的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,match[N],pre[N];</span><br><span class="line"><span class="keyword">bool</span> vis2[N];</span><br><span class="line">ll favor[N][N],val1[N],val2[N],slack[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y=<span class="number">0</span>,yy=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span> pre);</span><br><span class="line">	<span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span> slack);</span><br><span class="line">	match[<span class="number">0</span>]=p;  <span class="comment">// </span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ll d=INF;</span><br><span class="line">		x=match[y];</span><br><span class="line">		vis2[y]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis2[i])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(slack[i]&gt;val1[x]+val2[i]-favor[x][i]) &#123;</span><br><span class="line">				slack[i]=val1[x]+val2[i]-favor[x][i];</span><br><span class="line">				pre[i]=y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(slack[i]&lt;d) &#123;</span><br><span class="line">				d=slack[i]; <span class="comment">//d取最小可能</span></span><br><span class="line">				yy=i; <span class="comment">//记录最小可能存在的点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis2[i])</span><br><span class="line">				val1[match[i]]-=d,val2[i]+=d;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				slack[i]-=d;</span><br><span class="line">		&#125;</span><br><span class="line">		y=yy;</span><br><span class="line">	&#125; <span class="keyword">while</span>(match[y]);</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		match[y]=match[pre[y]]; <span class="comment">//bfs对访问路径进行记录，并在最后一并改变match</span></span><br><span class="line">		y=pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">	<span class="built_in">memset</span>(val1,<span class="number">0</span>,<span class="keyword">sizeof</span> val1);</span><br><span class="line">	<span class="built_in">memset</span>(val2,<span class="number">0</span>,<span class="keyword">sizeof</span> val2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis2,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis2);</span><br><span class="line">		<span class="built_in">bfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		res+=favor[match[i]][i]; <span class="comment">//最后将对应匹配的边权求和输出</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			favor[i][j]=-INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		favor[u][v]=<span class="built_in">max</span>(favor[u][v],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">KM</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形象理解"><a href="#形象理解" class="headerlink" title="形象理解"></a>形象理解</h2><p>参考网上对于这一算法的形象理解</p>
<p>现在有N男N女，有些男生和女生之间互相有好感，我们将其好感程度定义为好感度，我们希望把他们两两配对，并且最后希望好感度和最大。</p>
<p><img src="https://z3.ax1x.com/2021/08/01/WzmR00.png" alt="670878-20170604131038711-1791348557"></p>
<p>怎么选择最优的配对方法呢？</p>
<p>首先，每个女生会有一个期望值，就是与她有好感度的男生中最大的好感度。男生呢，期望值为0，就是……只要有一个妹子就可以啦，不挑~~</p>
<p>这样，我们把每个人的期望值标出来。</p>
<p><img src="https://z3.ax1x.com/2021/08/01/Wznn3Q.png" alt="KM算法详解-wenr"></p>
<p>接下来，开始配对。</p>
<p>配对方法：</p>
<p>我们从第一个女生开始，分别为每一个女生找对象。</p>
<p>每次都从第一个男生开始，选择一个男生，使男女两人的<strong>期望和要等于两人之间的好感度</strong>。</p>
<p><strong>注意：每一轮匹配，每个男生只会被尝试匹配一次！</strong></p>
<h3 id="具体匹配过程"><a href="#具体匹配过程" class="headerlink" title="具体匹配过程"></a>具体匹配过程</h3><p><strong>为女1找对象</strong></p>
<p>（此时无人配对成功）</p>
<p>根据 “男女两人的期望和要等于两人之间的好感度”的规则</p>
<p>女1-男1：4+0 $\not=$ 3</p>
<p>女1-男3：4+0 $=$ 4</p>
<p>所以女1选择了男3</p>
<p><strong>女1找对象成功</strong></p>
<hr>
<p><strong>为女2找对象</strong></p>
<p>（此时女1—男3）</p>
<p>根据配对原则，女2选择男3</p>
<p>男3有主女1，女1尝试换人</p>
<p>我们尝试让女1去找别人</p>
<p>尝试失败</p>
<p>为女2找对象失败！</p>
<p><strong>为女2找对象失败</strong></p>
<hr>
<p>这一轮参与匹配的人有：女1，女2，男3。</p>
<p>怎么办？？？很容易想到的，这两个女生只能降低一下期望值了，降低多少呢？</p>
<p><strong>任意一个参与匹配女生能换到任意一个 <em>这轮</em> 没有被选择过的男生所需要降低的最小值</strong></p>
<p>比如：女1选择男1，期望值要降低1。 女2选择男1，期望值要降低1。 女2选择男2，期望值要降低2。</p>
<p>于是，只要期望值降低1，就有妹子可能选择其他人。所以<strong>妹子们的期望值要降低</strong>1点。</p>
<p>同时，刚才被抢的<strong>男生</strong>此时非常得意，因为有妹子来抢他，于是他的<strong>期望值提高</strong>了1点（就是同妹子们降低的期望值相同）。</p>
<p>于是期望值变成这样（当然，不参与刚才匹配过程的人期望值不变）</p>
<p><img src="https://z3.ax1x.com/2021/08/01/Wznm9g.png" alt="KM详解-wenr"></p>
<p><strong>继续为女2找对象</strong></p>
<p>（此时女1—男3）</p>
<p>女2选择了男1</p>
<p>男1还没有被配对</p>
<p>女2找对象成功！</p>
<p><strong>为女2找对象成功</strong></p>
<hr>
<p><strong>为女3找对象</strong></p>
<p>（此时女1—男3，女2-男1）</p>
<p>女3没有可以配对的男生……</p>
<p>女3找对象失败</p>
<p><strong>为女3找对象失败</strong></p>
<hr>
<p>此轮只有女3参与匹配</p>
<p>此时应该为女3降低期望值</p>
<p>降低期望值1的时候，女3-男3可以配对，所以女3降低期望值1</p>
<p><img src="https://z3.ax1x.com/2021/08/01/WznZ4S.png" alt="KM算法详解"></p>
<p><strong>继续为女3找对象</strong></p>
<p>（此时女1—男3， 女2-男1）</p>
<p>女3相中了男3</p>
<p>此时男3已经有主女1，于是女1尝试换人</p>
<p>女1选择男1</p>
<p>而男1也已经有主女2，女2尝试换人</p>
<p>前面说过，每一轮匹配每个男生只被匹配一次</p>
<p>所以女2换人失败</p>
<p>女3找对象再次失败</p>
<p><strong>为女3找对象失败</strong></p>
<hr>
<p>这一轮匹配相关人员：女1，女2，女3，男1，男3</p>
<p>此时，只要女2降低1点期望值，就能换到男2</p>
<p>（前面提过 只要任意一个女生能换到任意一个没有被选择过的男生所需要降低的最小值）</p>
<p>我们把相应人员期望值改变一下</p>
<p><img src="https://z3.ax1x.com/2021/08/01/WznVN8.png" alt=""></p>
<p><strong>还是为女3找对象</strong></p>
<p>（此时女1—男3， 女2-男1）</p>
<p>女3选择了男3</p>
<p>男3有主女1，女1尝试换人</p>
<p>女1换到了男1</p>
<p>男1已经有主女2，女2尝试换人</p>
<p>女2换人男2</p>
<p>男2无主，匹配成功！！！</p>
<p><strong>为女3找对象成功</strong></p>
<hr>
<p>匹配成功！！！撒花~~</p>
<p>到此匹配全部结束</p>
<p>此时</p>
<p>女1-男1，女2-男2，女3-男3</p>
<p>好感度和为最大：9</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大权匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 D Rebuild Tree 与 Prufer序列知识点</title>
    <url>/2021/07/28/nowcoder4d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定一棵$n$个节点的树，现在删掉$k$条边再加上$k$条边再成为一棵树，问总方案数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
 1 \leq n \leq 5 \cdot 10^4\\
 k \leq min(n-1,100)</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这道题很好体现了两个基本问题——<strong>树的删边</strong>和<strong>树的计数</strong>。</p>
<p>对于树的删边问题，我们考虑删除$k$条边后形成的$k+1$​个连通块，记它们的大小为$s[1],s[2],…,s[k+1]$，为了计数方便，我们把这些连通块都抽象为一个点，那么这些点<strong>相互连接</strong>，需要枚举一个<strong>点度数</strong>，所以我们的方案数应该是</p>
<script type="math/tex; mode=display">
\sum_{\text{Tree of k+1 nodes}} \prod_{i=1}^{k+1} s_i^{d_{i}}</script><p>出现了点度数，我们不妨用Prufer序列的性质来化简这个式子（具体知识见下文），我们可以得到上式为：</p>
<script type="math/tex; mode=display">
\sum_{\forall s[1..k+1]} n^{k-1}\cdot\prod_{i=1}^{k+1}s_i</script><p>那么问题来了，其实$n^{k-1}$并不难算，关键是我们很难枚举所有的连通块大小为这个s序列的所有树的形态。于是我们谋求问题的转化：</p>
<p>上面这个式子把$n^{k-1}$​单提到外面后，剩下的$\sum$​等价于<em>我将原先这个树切了$k$​​​条边，剩下的连通块恰好选1个点的总方案数。**</em>恰好选一个点**这件事正是对于这个$\prod$</p>
<p>而这个问题就可以用树形DP来解决了。记$dp[x][y][0/1]$表示$x$的子树，一共删$y$条边，且$x$节点所在的连通块是否选中了点时的方案数。其状态转移可以在DFS时逐一添加子树来计算，具体转移见如下代码。</p>
<p>值得一提的是，根据出题人的讲评，这个DFS过程乍一看是$O(nk^2)$的，实际上是$O(nk)$的，因此可以通过。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line">LL dp[MAXN][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN];</span><br><span class="line">LL tmp[<span class="number">220</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//子树一条边不删的话形态是唯一的 </span></span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_dp</span>(v,u);</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));<span class="comment">//注意顺序 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;siz[u] &amp;&amp; i&lt;=k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;siz[v] &amp;&amp; i+j&lt;=k; j++) &#123;</span><br><span class="line">				<span class="comment">//Not delete.</span></span><br><span class="line">				tmp[i+j][<span class="number">0</span>]=(tmp[i+j][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">0</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j][<span class="number">1</span>]=(tmp[i+j][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">0</span>]%MOD</span><br><span class="line">				             +dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				<span class="keyword">if</span>(i+j==k)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//delete one more.  得符合定义，底下的儿子节点所在连通块相对独立，故必须选中 </span></span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(dp[u],tmp,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	n=<span class="built_in">mread</span>(),k=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		u=<span class="built_in">mread</span>(),v=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][k][<span class="number">1</span>]*<span class="built_in">quick_pow</span>(n,k<span class="number">-1</span>)%MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prufer序列"><a href="#Prufer序列" class="headerlink" title="Prufer序列"></a>Prufer序列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>对于一个$n$​​个节点的标号树，其Prufer序列是惟一的，长度为$n-2$。因此可以用于<strong>树的形态计数</strong>等问题。</p>
<p>其<strong>构造方法</strong>如下：</p>
<p>①选择当前树中编号最小的叶子，将其删除</p>
<p>②将刚才删除的叶子的父节点加入到序列中</p>
<p>③重复前两步，直到树为空</p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>根据Prufer序列的构造方法，不难看出以下的性质：</p>
<h4 id="一、一个点的度数-其在Prufer序列中出现次数-1"><a href="#一、一个点的度数-其在Prufer序列中出现次数-1" class="headerlink" title="一、一个点的度数 = 其在Prufer序列中出现次数 + 1"></a>一、一个点的度数 = 其在Prufer序列中出现次数 + 1</h4><h4 id="二、n个点的无根标号树形态总数为-n-n-2"><a href="#二、n个点的无根标号树形态总数为-n-n-2" class="headerlink" title="二、n个点的无根标号树形态总数为 $n^{n-2}$"></a>二、n个点的无根标号树形态总数为 $n^{n-2}$</h4><p>这一条原因是我们可以枚举Prufer序列，而每一个位置可以在$[1…n]$中任取</p>
<h4 id="三、n个点的有根标号树形态总数为-n-n-1"><a href="#三、n个点的有根标号树形态总数为-n-n-1" class="headerlink" title="三、n个点的有根标号树形态总数为$n^{n-1}$"></a>三、n个点的有根标号树形态总数为$n^{n-1}$</h4><p>其实就是第二条再枚举根节点。</p>
<h4 id="四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i"><a href="#四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i" class="headerlink" title="四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$"></a>四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$</h4><script type="math/tex; mode=display">
\frac{(n-2)!}{\prod_{i=1}^{n}(d_i-1)!}</script><h6 id="这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"><a href="#这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。" class="headerlink" title="这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"></a>这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。</h6>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营3 C Minimum grid</title>
    <url>/2021/07/28/nowcoder3c/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有一个$n \times n$的方阵，其中一些格子可以填数，其他格子均不能填数，且每行有一个最大值要求$b_i$，每列有一个最大值要求$c_i$，即填的数得保证这些最大值要求被满足。现在求最小的填数之和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n\leq 2\cdot 10^3\\</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这种看起来具体需要“填一填”弄出具体方案的题目，不妨从<strong>必要条件</strong>入手去分析。我们猜测，在不填“多余的数”的情况下，这个和至少得是$\sum_{i=1}^n b_i+c_i$​​。很快我们发现这个必要条件可以优化，其实就是如果一个格子<strong>对应行列的最大值要求时相等</strong>的，那么其实填这个格子就<strong>节省</strong>了一个最大值。（如果不相等的话是不能实现“1换2”的）</p>
<p>所以我们的目标就是找出所有能够节省最大值的情况——<strong>同一行同一列</strong>只在上述的<strong>一个</strong>这种格子上放数，才能实现节省。于是我们用二分图求最大匹配来配置这些格子，即这种格子的行列连边，然后跑二分图匹配。再从答案中减掉匹配成功对应行列的最大值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> b[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">namespace</span> graph &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		node *nnext;</span><br><span class="line">	&#125; pool[<span class="number">2</span>*N],*h[<span class="number">2</span>*N];</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		node *p=&amp;pool[++cnt];</span><br><span class="line">		p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">		node *q=&amp;pool[++cnt];</span><br><span class="line">		q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> connect[N];</span><br><span class="line">	<span class="keyword">bool</span> state[N];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">			v=p-&gt;v;</span><br><span class="line">			<span class="keyword">if</span>(!state[v]) &#123;</span><br><span class="line">				state[v]=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(connect[v]==<span class="number">0</span> || <span class="built_in">dfs</span>(connect[v])) &#123;</span><br><span class="line">					connect[v]=u;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LL ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(state,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(state));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(j))</span><br><span class="line">				ret+=b[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">		ans+=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">		ans+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(b[u]==c[v])</span><br><span class="line">			graph::<span class="built_in">addedge</span>(u,n+v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans - graph::<span class="built_in">hungary</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大匹配</tag>
        <tag>构图</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) Buggy Robot</title>
    <url>/2021/07/30/gym101201B/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有个机器人在一个网格中靠执行一串<code>LRUD</code>指令行动，但这串指令有问题，并不能保证机器人一定能从起点走到终点。当机器人执行一条指令可能出界或遇到障碍，则相当于这条指令无效。而一旦机器人到达了终点，则之后未执行的指令都不用执行。现在问在原串上最少增添多少条指令，可以使机器人从起点到达终点。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m,k \leq 50</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>看到字符串就想匹配，有些狭隘了。确实有匹配的因素，但我们关心的是<strong>从一个字符到下一个字符的转移</strong>，而并非事先构造出整个串。其实我们<strong>并不关心具体增添那些</strong>指令，只关心最小增添的<strong>个数</strong>。而增添的情形，实际上是由坐标来决定的。</p>
<p>因此我们记$dp[i][j][k]$表示当前机器人位于$(i,j)$，即将执行第$k$​条指令时，​达到此状态最小的增添指令次数。那么其实还是枚举四个方向的情形，如果恰好枚举的方向和指令方向一致的话，就去更新$(i’,j’,k+1)$状态的dp值，否则相当于到了下一个点还是执行第$k$条指令。</p>
<p>复杂度为$O(nmk)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>],cmd[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,k;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((x&gt;=<span class="number">1</span>) &amp;&amp; (x&lt;=n) &amp;&amp; (y&gt;=<span class="number">1</span>) &amp;&amp; (y&lt;=m) &amp;&amp; mp[x][y]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;U&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> dy[<span class="number">4</span>]= &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//rows &amp; cols</span></span><br><span class="line">	node now,nxt;</span><br><span class="line">	<span class="keyword">int</span> cmd_go;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">					i,j,<span class="number">1</span></span><br><span class="line">				&#125;);</span><br><span class="line">				dp[i][j][<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//字符串标号 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		now=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		printf(&quot;%d %d %d val=%d\n&quot;,now.x,now.y,now.k-1,dp[now.x][now.y][now.k]); </span></span><br><span class="line"><span class="comment">//		system(&quot;PAUSE&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(mp[now.x][now.y]==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,dp[now.x][now.y][now.k]);  <span class="comment">//可以不执行完既定的指令</span></span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">//!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">			nxt.x=now.x+dx[i];</span><br><span class="line">			nxt.y=now.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(now.k&lt;=len)</span><br><span class="line">				cmd_go=<span class="built_in">num</span>(cmd[now.k]);</span><br><span class="line">			<span class="keyword">else</span> cmd_go=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(nxt.x,nxt.y)) &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//This is an invalid direct.</span></span><br><span class="line">						<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>]==INF)</span><br><span class="line">							Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">							now.x,now.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[now.x][now.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line"><span class="comment">//					printf(&quot;??\n&quot;);</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//No need to add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;<span class="comment">//Guaranteed that len will not be exceeded.</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] &gt; dp[now.x][now.y][now.k] + <span class="number">1</span>) &#123; <span class="comment">//add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k</span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k]=dp[now.x][now.y][now.k] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;B.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;B-1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd+<span class="number">1</span>);</span><br><span class="line">	len=<span class="built_in">strlen</span>(cmd+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">63</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,0x3f3f3f3f);</span></span><br><span class="line">	ans=INF;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,dp[0][0][0],ans);</span></span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>递推与动归</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营5 Cheating and Stealing</title>
    <url>/2021/08/04/nowcoder5c/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>甲乙两个人比赛乒乓，已知每一个<strong>回合</strong>的胜负的描述序列$S$，现在设$f_i(S)$表示当局点分为$i$时甲赢得比赛的次数，求：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^n f_i(S)\cdot (|S|+1)^{i-1}</script><p>其中赢得比赛是指该人已经超过局点分且超过对手至少两分。一局比赛结束后，下一局比赛的情形继续沿回合序列进行。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq |S| \leq 10^6</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题最朴素的思路就是针对一个局点分来分析赢球的局数。其实这样也是可行的，因为<strong>分析复杂度</strong>，假设当前分析的局点分是$i$​，那么场次不会超过$\frac{|S|}{i}$​,因此如果我们能够在$O(1)$​的复杂度内完成下一局的分析，那么总复杂度就是$O(|S|log|S|)$</p>
<p>下面考虑怎么来$O(1)$​知道每一局在序列中的起始和终止位置。首先我们用前缀和$sumW,sumL$​来维护到序列某个位置$i$​​,两人分别能赢多少回合，同时记录下来每个人赢第几个回合是对应序列中的哪个位置$posW,posL$​​。然后我们枚举下一个局点分到底由谁来得（这里见文末代码即可知）。</p>
<p>这里需要<strong>加速</strong>的地方在于<strong>两人交替赢球</strong>使得没有人能够超过对方两分的情形。这种局面可以预处理，即$tiebreak[i]=(s[i]==s[i+1]) ?i+1:tiebreak[i+2]$.</p>
<p>因此由上述两点进行递推判定即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001000</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[MAXN];</span><br><span class="line"><span class="keyword">int</span> sumL[MAXN],sumW[MAXN];</span><br><span class="line"><span class="keyword">int</span> posW[MAXN],posL[MAXN];</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">		a=<span class="number">1ll</span>*a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> tiebreak[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> k;</span><br><span class="line">	n=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		sumL[i]=sumL[i<span class="number">-1</span>];</span><br><span class="line">		sumW[i]=sumW[i<span class="number">-1</span>];</span><br><span class="line">		<span class="keyword">if</span>(s[i]==<span class="string">&#x27;W&#x27;</span>) &#123;</span><br><span class="line">			sumW[i]++;</span><br><span class="line">			posW[sumW[i]]=i;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sumL[i]++;</span><br><span class="line">			posL[sumL[i]]=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> now,res,nxt;</span><br><span class="line">	<span class="keyword">int</span> winL,winW;</span><br><span class="line">	tiebreak[n+<span class="number">1</span>]=tiebreak[n]=n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">		tiebreak[i]=(s[i]==s[i+<span class="number">1</span>]) ? i+<span class="number">1</span> : tiebreak[i+<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		now=<span class="number">0</span>;</span><br><span class="line">		res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(now&lt;n) &#123;</span><br><span class="line">			nxt=n+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(sumW[now]+i &lt;= sumW[n])nxt=<span class="built_in">min</span>(nxt,posW[sumW[now]+i]);</span><br><span class="line">			<span class="keyword">if</span>(sumL[now]+i &lt;= sumL[n])nxt=<span class="built_in">min</span>(nxt,posL[sumL[now]+i]);</span><br><span class="line">			<span class="keyword">if</span>(nxt&gt;n)<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">			winL=sumL[nxt] - sumL[now];</span><br><span class="line">			winW=sumW[nxt] - sumW[now];</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(winL-winW)==<span class="number">1</span>)nxt=tiebreak[nxt];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(nxt&gt;n)<span class="keyword">break</span>;</span><br><span class="line">			winL=sumL[nxt] - sumL[now];</span><br><span class="line">			winW=sumW[nxt] - sumW[now];</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(winW&gt;winL)res++;</span><br><span class="line">			now=nxt; </span><br><span class="line"><span class="comment">//			printf(&quot;%d\n&quot;,now);</span></span><br><span class="line">		&#125;</span><br><span class="line">		ans=(ans+<span class="number">1ll</span>*res*<span class="built_in">quick_pow</span>(n+<span class="number">1</span>,i<span class="number">-1</span>)%MOD)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 G Product</title>
    <url>/2021/07/27/nowcoder4g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定三个整数$n,k,D$,设数列$a_i,i=1,2,…,n$,求对于所有数列满足$\forall i \in [1,n],a_i \geq 0$​且$\sum_{i=1}^na_i=D$​的情况下，</p>
<script type="math/tex; mode=display">
\frac{D!}{\prod_{i=1}^n(a_i+k)!}</script><p>的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 50\\
0\leq k \leq 50\\
D \leq 10^8</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>此题比较神仙。首先分母上$(a_i+k)!$​不太好看，假设一个$a_i :=a_i+k$​.我们考虑一个<strong>组合模型</strong>，一个长度为D的数列，每个位置上可以填$[1,n]$中的任何正整数，一共有多少中填法。通过算两次，假设我们枚举$i$出现的次数为$a_i$​，或者直接乘法原理，那么这个组合模型的描述为</p>
<script type="math/tex; mode=display">
(\sum_{a_i\geq0}=D) \prod_{i=1}^n \frac{D!}{a_i!}=n^D</script><p>那么回到本题。如果不要求$a_i \geq 0$即$a_i+k \geq k$时，则答案就是$n^{D+nk}$</p>
<p>现在问题就是必须要求$a_i+k\geq k$。因此我们用容斥原理做。</p>
<p>由于$n,k$都比较小，所以不妨记$dp[i][j]$表示“有$i$个数不满足要求且这$i$个数的和是$j$”，对于剩下的$n-i$​个数可以满足要求也可以不满足要求，其和也是确定的$D+nk-j$.因此我们可以求出”至少有$i$​个数不满足要求时对答案的贡献”:</p>
<script type="math/tex; mode=display">
C_{n}^{i} \cdot \sum_j dp[i][j]\cdot(n-i)^{D+nk-j}</script><p>因此答案就是$n^{D+nk}$减去”至少一个违反条件的”加上“至少两个违反条件的”减去“至少三个违反条件的”…如此递推即可。</p>
<p>最后再乘上$\frac{D!}{(D+nk)!}$满足题意。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营5 E Eert Esiwtib</title>
    <url>/2021/08/05/nowcoder5e/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给出一棵树，每条边上有一个位运算符，每个点有一个点权。现在有若干询问，每次询问会修改所有点的点权，并询问以$u$为根的子树中，从所有节点$v$到$u$的路径的位运算结果的位或和，位与和和异或和。</p>
<script type="math/tex; mode=display">
1 \leq n ,q\leq 2\cdot 10^5\\
0 \leq d \leq 100\\</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这题首先启示我们，不要看到是树上路径就害怕。像这种从叶子走到根的路径，其实只要搞明白<strong>树形DP</strong>中怎么从儿子到父节点的边的转移，其实实现并不复杂。</p>
<p>这个题也是一样，我们记$dp[u][0/1/2]$表示以$u$​为根的子树的所有到根的路径的位或和，位与和和异或和。接下来就是转移。而这个转移其实就是一个分类讨论的范式题（考查上学期离散数学/数理逻辑学得怎么样 汗）</p>
<p>其实推导基本上就是用当前讨论的某种和对应的运算，来化简系列式子（相当于枚举$v$的子树中的所有点，增加了一段$v\to u$​的运算路径）比如边权为$XOR$,要计算的权和为$OR$：</p>
<script type="math/tex; mode=display">
dp|=(A \;XOR\; v_1) |(A \;XOR \;v_2)|...|(A \;XOR\;v_n)\\</script><p>然后方便起见只用考虑两三个变量的情况。所以上式通过<strong>列真值表</strong>可知化简为形如</p>
<script type="math/tex; mode=display">
dp|=(\lnot A \land V)\lor(A\land \lnot V)</script><p>具体细节见代码即可。</p>
<p>此外，注意初始化。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) (a)&gt;(b) ? (a) : (b)</span></span><br><span class="line"><span class="function">LL <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v,len;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;len=len,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;len=len,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN];</span><br><span class="line">LL a[MAXN],val[MAXN];</span><br><span class="line">LL dp[MAXN][<span class="number">3</span>],ans[MAXN][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qry</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> d,u,id;</span><br><span class="line">	LL val1,val2,val3;</span><br><span class="line">&#125; qwq[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(qry s,qry t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.d &lt; t.d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(qry s,qry t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s.id &lt; t.id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>]=dp[u][<span class="number">2</span>]=<span class="number">0</span>,dp[u][<span class="number">1</span>]=<span class="number">-1</span>;<span class="comment">//init!</span></span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(v!=fa) &#123;</span><br><span class="line">			<span class="built_in">dfs</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(p-&gt;len==<span class="number">0</span>) &#123;</span><br><span class="line">				dp[u][<span class="number">0</span>]|=(val[u]|dp[v][<span class="number">0</span>]);</span><br><span class="line">				dp[u][<span class="number">1</span>]&amp;=(val[u]|dp[v][<span class="number">1</span>]);</span><br><span class="line">				dp[u][<span class="number">2</span>]^=(~val[u])&amp;dp[v][<span class="number">2</span>];</span><br><span class="line">				dp[u][<span class="number">2</span>]^=(siz[v] &amp; <span class="number">1</span>) ? val[u] : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;len==<span class="number">1</span>) &#123;</span><br><span class="line">				dp[u][<span class="number">0</span>]|=(val[u] &amp; dp[v][<span class="number">0</span>]);</span><br><span class="line">				dp[u][<span class="number">1</span>]&amp;=(val[u] &amp; dp[v][<span class="number">1</span>]);</span><br><span class="line">				dp[u][<span class="number">2</span>]^=(val[u] &amp; dp[v][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;len==<span class="number">2</span>) &#123;</span><br><span class="line">				dp[u][<span class="number">0</span>]|=(~val[u]&amp;dp[v][<span class="number">0</span>])|(val[u]&amp;~dp[v][<span class="number">1</span>]);</span><br><span class="line">				dp[u][<span class="number">1</span>]&amp;=(~val[u]&amp;dp[v][<span class="number">1</span>])|(val[u]&amp;~dp[v][<span class="number">0</span>]);</span><br><span class="line">				dp[u][<span class="number">2</span>]^=dp[v][<span class="number">2</span>]^(siz[v]&amp;<span class="number">1</span>?val[u]:<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ans[u][<span class="number">0</span>]=dp[u][<span class="number">0</span>],ans[u][<span class="number">1</span>]=dp[u][<span class="number">1</span>],ans[u][<span class="number">2</span>]=dp[u][<span class="number">2</span>];</span><br><span class="line">	dp[u][<span class="number">0</span>]|=val[u],dp[u][<span class="number">1</span>]&amp;=val[u],dp[u][<span class="number">2</span>]^=val[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> f,s;</span><br><span class="line">	n=<span class="built_in">mread</span>(),q=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		f=<span class="built_in">mread</span>(),s=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(i+<span class="number">1</span>,f,s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++)qwq[i].d=<span class="built_in">mread</span>(),qwq[i].u=<span class="built_in">mread</span>(),qwq[i].id=i;</span><br><span class="line">	<span class="built_in">sort</span>(qwq+<span class="number">1</span>,qwq+q+<span class="number">1</span>,cmp1);</span><br><span class="line">	qwq[<span class="number">0</span>].d=<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++) &#123;</span><br><span class="line"><span class="comment">//		printf(&quot;%d %d\n&quot;,qwq[i].u,qwq[i].d);</span></span><br><span class="line">		<span class="keyword">if</span>(qwq[i].d!=qwq[i<span class="number">-1</span>].d) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)val[j]=a[j]+<span class="number">1ll</span>*j*qwq[i].d;</span><br><span class="line">			<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		qwq[i].val1=ans[qwq[i].u][<span class="number">0</span>];</span><br><span class="line">		qwq[i].val2=ans[qwq[i].u][<span class="number">1</span>];</span><br><span class="line">		qwq[i].val3=ans[qwq[i].u][<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(qwq+<span class="number">1</span>,qwq+q+<span class="number">1</span>,cmp2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=q; i++)<span class="built_in">printf</span>(<span class="string">&quot;%lld %lld %lld\n&quot;</span>,qwq[i].val1,qwq[i].val2,qwq[i].val3);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营6 C Delete Edges</title>
    <url>/2021/08/03/nowcoder6c/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给出一个$n$个点的完全图，删除一些三元环使得剩下的边数少于$n$条。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
3 \leq n \leq 2000</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题实在是一个构造题。说来惭愧，并不知道这个转化为何是正确的。值得记得就是递推的证明方法。</p>
<p>根据题解，问题转化为</p>
<p><strong>求$1\leq x&lt;y&lt;z\leq n$范围内满足$x+y+z\equiv 0(mod\;n)$​的方案组数。</strong></p>
<p>记答案为$f(n)$，下面证明该式具有递推$f(n+3)=f(n)+n$</p>
<p>证明的思路在于考虑答案的来源：$x+y+z=n$和$x+y+z=2n$两种情况。假设前一种情况的答案贡献为$ans1$，第二种情况对答案的贡献为$ans2$。</p>
<p>下面考虑将$n$时的$ans1,ans2$递推到$n+3$时的情况。</p>
<script type="math/tex; mode=display">
1 \leq x<y<z \leq n,&x+y+z=n:ans1\\
&(x+1)+(y+1)+(z+1)=n+3\\
2 \leq x<y<z\leq n+1,&x+y+z=n:ans1\\</script><p>当$z=n+2,n+3$时无解，当$x=1$时，满足$y+z=n+2$新增$[\frac{n-1}{2}]$组解，故得到</p>
<script type="math/tex; mode=display">
1 \leq x<y<z \leq n+3,x+y+z=n:ans1+\lfloor \frac{n-1}{2} \rfloor</script><p>再考虑$ans2的递推。</p>
<script type="math/tex; mode=display">
1 \leq x<y<z \leq n,&x+y+z=2n:ans2\\
&(x+2)+(y+2)+(z+2)=2(n+3)\\
3 \leq x<y<z \leq n+2,&x+y+z=2(n+3):ans2\\</script><p>当$x=1,2$时无解，当$z=n+3$时，$x+y=n+3$，有$\lfloor \frac{n+2}{2} \rfloor$组解。</p>
<p>故得到</p>
<script type="math/tex; mode=display">
1 \leq x<y<z \leq n+3,x+y+z=2n:ans2+\lfloor \frac{n+2}{2} \rfloor</script><p>因此总共新增$\lfloor\frac{n-1}{2}\rfloor+\lfloor\frac{n+2}{2}\rfloor=n$组解。递推由此得证。</p>
<p>再通过递推式结合$f(3)=1,f(4)=1,f(5)=2$初始值，得到通项公式：</p>
<script type="math/tex; mode=display">
ans[n]=
\begin{cases}
\frac{n^2-3n+6}{6},3|n\\
\frac{n^2-3n+2}{6},3\nmid n
\end{cases}</script>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>递推与动归</tag>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营6 J Defend Your Country</title>
    <url>/2021/08/04/nowcoder6j/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p> 𝑛个点，𝑚条边的简单无向联通图，每个点一个权值 𝑎𝑖；</p>
<p> 一个连通块的贡献： $(−1)^{块内点数} ⋅ ∑𝑎𝑖[点 𝑖 在该连通块内]$；</p>
<p> 可任意删除一些边，求连通块贡献之和最大是多少。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
 1 ≤ 𝑛, 𝑚 ≤ 10^6, 1 ≤ 𝑎_𝑖 ≤ 10^9</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先拿到问题看似很复杂，但应该从简单的，或者极端的情况进行考虑。因为所有的点权都是正的，所以我们想让尽可能多的连通块都有偶数大小。</p>
<p>那么我们可以考虑假设所有的点都是可以取正点权来贡献答案，再考虑删掉哪些点使得原本是奇数大小的连通块变成偶数大小。</p>
<p>从贪心的角度考虑，我们需要找奇数点权的联通块中<strong>点权最小的点</strong>来删。但是需要判定一个问题，就是有可能删除的点是<strong>割点</strong>，因此我们需要<strong>Tarjan</strong>一波找到所有的割点，并判断这些割点连接的各连通块，如果<strong>删除了割点是否还能保证是偶数大小</strong>。</p>
<p>这个题其实结论转化为代码是直接的。关键在于<strong>结论的得来</strong>。也就是为什么只用删除一个点即可？</p>
<p>首先总点数为偶数的情况是显然的。我们来考虑总点数$n$为奇数的情况。</p>
<h4 id="结论一：删除的节点一定是一些孤立点，且一共有奇数个。"><a href="#结论一：删除的节点一定是一些孤立点，且一共有奇数个。" class="headerlink" title="结论一：删除的节点一定是一些孤立点，且一共有奇数个。"></a>结论一：删除的节点一定是一些孤立点，且一共有奇数个。</h4><p>反证法：如果删除的不是孤立点，而是奇数连通块，那么完全可以把这些$size \geq3$​的连通块再删掉非割点以获得偶联通块增加答案。另一方面，如果孤立点一共有偶数个，则考虑删掉孤立点剩下的都是偶连通块，所以总点数为偶数，矛盾。</p>
<p>（下面的结论我暂时没明白）</p>
<h4 id="结论二：假设孤立点的个数大于等于3，则答案必为原图割点，且剩下的奇数连通块需要再次进行找割点的操作。"><a href="#结论二：假设孤立点的个数大于等于3，则答案必为原图割点，且剩下的奇数连通块需要再次进行找割点的操作。" class="headerlink" title="结论二：假设孤立点的个数大于等于3，则答案必为原图割点，且剩下的奇数连通块需要再次进行找割点的操作。"></a>结论二：假设孤立点的个数大于等于3，则答案必为原图割点，且剩下的奇数连通块需要再次进行找割点的操作。</h4><p>首先，这些点一定都是原图的割点。否则，在原图上存在一个非割点，则将其割去，分成一个孤立点和一个偶数的连通块，答案更大。</p>
<p> 现在如果在原图中把这些孤立点单独割去，那么剩下的连通块中一定存在至少两个奇数连通块（奇+奇=偶）。否则，可以仅需要单独割掉其中一个，答案会更优（原图总点数奇数=奇point+偶remain）。</p>
<p>（一个例子：假设原图组成为 <em>偶-割-偶-割-偶-割-偶</em>，<strong>单独割点最左或者最右的割点</strong>，其左右两个连通块点数都是偶数，<strong>比</strong>起把<strong>三个割点全部割掉</strong>答案<strong>更优</strong>。）</p>
<p>而由于至少两个连通块都是奇数个点，于是还需要在里面继续找割点并重复上面的操作。</p>
<h4 id="结论三：答案仅会删除一个点"><a href="#结论三：答案仅会删除一个点" class="headerlink" title="结论三：答案仅会删除一个点"></a>结论三：答案仅会删除一个点</h4><p>接下来，我们将割下来的孤立点放在<strong>点双树</strong>上，建立一棵虚树（不知道什么是点双树可以搜索圆方树，两者差不多是同一个东西），那么由于割点至少在两个方向上都有其他割点，但按照上述过程，存在孤立点必为叶子，即不可能在两个方向上都有其他割点。否则，这棵树就存在一个环。</p>
<p>一棵树怎么可能有环呢？假设不成立！</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000100</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dfn[MAXN],low[MAXN],ind,siz[MAXN];</span><br><span class="line"><span class="keyword">bool</span> is_cut[MAXN],ok[MAXN];<span class="comment">//ok[i]:i为割点且i删去后是否保证所有连通块都是偶数个点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v,son=<span class="number">0</span>;</span><br><span class="line">	low[u]=dfn[u]=++ind;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!dfn[v]) &#123;</span><br><span class="line">			<span class="built_in">Tarjan</span>(v,u);</span><br><span class="line">			siz[u]+=siz[v];</span><br><span class="line">			<span class="keyword">if</span>(u==fa)son++;  <span class="comment">//搜索树根节点是否为割点的判断</span></span><br><span class="line">			<span class="keyword">if</span>((siz[v]&amp;<span class="number">1</span>) &amp;&amp; low[v] &gt;= dfn[u])ok[u]=<span class="literal">false</span>;</span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">			<span class="keyword">if</span>(u!=fa &amp;&amp; low[v]&gt;=dfn[u])is_cut[u]=<span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(u==fa &amp;&amp; son &gt; <span class="number">1</span>)is_cut[u]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> mmin,now_size;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	vis[u]=<span class="literal">true</span>;</span><br><span class="line">	now_size++;</span><br><span class="line">	<span class="keyword">if</span>((!is_cut[u] || (is_cut[u] &amp;&amp; ok[u])) &amp;&amp; a[u] &lt; mmin)mmin=a[u];</span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(!vis[v])</span><br><span class="line">			<span class="built_in">dfs</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	n=<span class="built_in">mread</span>(),m=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">mread</span>();</span><br><span class="line">		ans+=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		u=<span class="built_in">mread</span>(),v=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)ok[i]=<span class="literal">true</span>; <span class="comment">//假设割点删去后都是偶数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!dfn[i])</span><br><span class="line">			<span class="built_in">Tarjan</span>(i,i);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">if</span>(!vis[i]) &#123;</span><br><span class="line">			mmin=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">			now_size=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">dfs</span>(i);</span><br><span class="line">			<span class="keyword">if</span>(now_size &amp; <span class="number">1</span>)</span><br><span class="line">				ans-=<span class="number">2ll</span>*mmin;  <span class="comment">//删除且取负 </span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)pool[i].v=<span class="number">0</span>,pool[i].nnext=<span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		h[i]=<span class="literal">NULL</span>;</span><br><span class="line">		dfn[i]=low[i]=vis[i]=siz[i]=<span class="number">0</span>;</span><br><span class="line">		is_cut[i]=ok[i]=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ind=<span class="number">0</span>;</span><br><span class="line">	cnt=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> kase;</span><br><span class="line">	kase=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">while</span>(kase--) &#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>点双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营6 Hopping Rabbit</title>
    <url>/2021/08/02/nowcoder6h/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>平面上有$n$个矩形，给定一个跨度$d$，需要找到一个位置$(x_0,y_0)$使得所有$(x_0+0.5+kd,y_0+0.5+kd)$均不落在矩形范围内。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 2\cdot 10^5</script><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>扫描线的经典做法。就是横轴从左到右处理添加和删除事件，纵轴线段树动态维护当前区间的最小值。然后看平面上是否有一个点不在禁止区域中。具体细节见代码。考场上主要WA的原因是：</p>
<p>1、代码结构不好</p>
<p>2、y2的处理有问题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp;c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200100</span></span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line"><span class="keyword">int</span> mmin[MAXN&lt;&lt;<span class="number">2</span>],lazy[MAXN&lt;&lt;<span class="number">2</span>],m_id[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></span><br><span class="line">	<span class="keyword">bool</span> typ;</span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">&#125; ;</span><br><span class="line">vector&lt;rec&gt; lines[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ql,qr,qval;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(lazy[id]) &#123;</span><br><span class="line">		mmin[id&lt;&lt;<span class="number">1</span>]+=lazy[id];</span><br><span class="line">		mmin[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[id];</span><br><span class="line">		lazy[id&lt;&lt;<span class="number">1</span>]+=lazy[id];</span><br><span class="line">		lazy[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+=lazy[id];</span><br><span class="line">		lazy[id]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	mmin[id]=<span class="built_in">min</span>(mmin[id&lt;&lt;<span class="number">1</span>],mmin[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">	m_id[id]=(mmin[id&lt;&lt;<span class="number">1</span>] &lt; mmin[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]) ? m_id[id&lt;&lt;<span class="number">1</span>] : m_id[id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=l &amp;&amp; r&lt;=qr) &#123;</span><br><span class="line">		mmin[id]+=qval;</span><br><span class="line">		lazy[id]+=qval;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">push_down</span>(id);</span><br><span class="line">	<span class="keyword">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(ql&lt;=mid)<span class="built_in">change</span>(id&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="keyword">if</span>(mid&lt;qr)<span class="built_in">change</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">upd</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l==r) &#123;</span><br><span class="line">		m_id[id]=l;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	<span class="built_in">build</span>(id&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">	<span class="built_in">build</span>(id&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	<span class="built_in">upd</span>(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> l1,l2,r1,r2;</span><br><span class="line">	<span class="keyword">int</span> x1,x2,y1,y2;</span><br><span class="line">	<span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">	n=<span class="built_in">mread</span>(),d=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		x1=<span class="built_in">mread</span>(),y1=<span class="built_in">mread</span>(),x2=<span class="built_in">mread</span>(),y2=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="keyword">if</span>(x2-x1&gt;=d &amp;&amp; y2-y1&gt;=d)</span><br><span class="line">			flag=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			l1=(x1%d+d)%d;</span><br><span class="line">			l2=(x2%d+d)%d;</span><br><span class="line">			r1=(y1%d+d)%d;</span><br><span class="line">			r2=(y2%d+d)%d;</span><br><span class="line">			<span class="keyword">if</span>(x2-x1&gt;=d)l1=<span class="number">0</span>,l2=d;</span><br><span class="line">			<span class="keyword">if</span>(y2-y1&gt;=d)r1=<span class="number">0</span>,r2=d;</span><br><span class="line">			<span class="keyword">if</span>(l1 &lt; l2) &#123;</span><br><span class="line">				<span class="keyword">if</span>(r1 &gt; r2) &#123; <span class="comment">//比较的方面？</span></span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,<span class="number">0</span>,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,d<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,<span class="number">0</span>,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,r1,d<span class="number">-1</span>&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,r1,r2<span class="number">-1</span>&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(r1 &gt; r2) &#123; <span class="comment">//比较的方面？</span></span><br><span class="line">					lines[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,<span class="number">0</span>,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,d<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,<span class="number">0</span>,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,r1,d<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,<span class="number">0</span>,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,d<span class="number">-1</span>&#125;);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					lines[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l2].<span class="built_in">push_back</span>(&#123;<span class="literal">false</span>,r1,r2<span class="number">-1</span>&#125;);</span><br><span class="line">					lines[l1].<span class="built_in">push_back</span>(&#123;<span class="literal">true</span>,r1,r2<span class="number">-1</span>&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(flag==<span class="literal">false</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	flag=<span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">0</span>,d<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;d; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;lines[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">			ql=lines[i][j].l,qr=lines[i][j].r;</span><br><span class="line">			<span class="keyword">if</span>(ql&lt;=qr) &#123;</span><br><span class="line">				qval=((lines[i][j].typ==<span class="literal">true</span>) ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">				<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">0</span>,d<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(mmin[<span class="number">1</span>]==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,m_id[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里借鉴了两件事：</p>
<p>1、用vector来处理同一横坐标的各个事件</p>
<p>2、直接维护贡献最小值的点，而不是再暴力找。（虽然暴力找也能过）。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树</tag>
        <tag>扫描线</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu AI相关软件安装心得（1）</title>
    <url>/2021/07/30/pythonDL/</url>
    <content><![CDATA[<p>在Ubuntu上安装<code>tensorflow</code>的过程真是一波三折，挺折腾人的。期间也查阅了不少CSDN的博客。不过也算是增进了对Ubuntu系统的了解和终端的使用吧。</p>
<p>好不容易入手了配有较高水平GPU的笔记本，当然要安装<code>tensorflow-gpu</code>版本了！不过经过摸索（呜呜呜），这个<code>gpu</code>版本的安装并不简简单单是一行pip就能解决的问题。依次要安装好<code>nvidia</code>显卡，<code>CUDA</code>和<code>cuDNN</code>,当然还有<code>Anaconda</code>等。由于之前出于省事安装了个<code>LambdaStack</code>，现在这些个软件包其实是混乱的，就可能许多软件包已经下载到电脑里了，只不过没有启用或者依赖关系没有解决云云。</p>
<p>具体的命令行就不写了，网上大多能查到。就记一记在自己电脑上试的坑。</p>
<h2 id="NVIDIA显卡的安装"><a href="#NVIDIA显卡的安装" class="headerlink" title="NVIDIA显卡的安装"></a>NVIDIA显卡的安装</h2><p>1、要禁用、卸载Ubuntu自带的nouveau驱动</p>
<p>2、卸载曾经安装残存的<code>nvidia</code>驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove nvidia-*</span><br></pre></td></tr></table></figure>
<p>3、安装NVIDIA驱动时必须要关闭图形界面<code>Ctrl+Alt+F1</code>进入<code>tty</code>虚拟命令行，把命令先写下来，因为一时上不了网。</p>
<p>大概有这么几条</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service lightdm stop  //关闭图形界面</span><br><span class="line">sudo chmod a+x ...</span><br><span class="line">sudo ./... (此处为驱动) -no-x-check -no-nouveau-check -no-opengl-files</span><br></pre></td></tr></table></figure>
<p>然后一通安装，期间有设置安全启动密码什么的，最好记住。然后重启</p>
<p>检查是否安装成功，执行<code>nvidia-smi</code>如果能够看到一张大表格就行了</p>
<p>还有一条<code>modprobe nvidia</code>似乎是启用</p>
<p>4、此外必要时需要在BIOS中设置关闭安全启动。</p>
<h2 id="CUDA的安装"><a href="#CUDA的安装" class="headerlink" title="CUDA的安装"></a>CUDA的安装</h2><p>最麻烦的就是出现诸如“下列软件包有未满足的依赖关系： cuda : 依赖: cuda-11-4 (&gt;= 11.4.xxx) 但是它将不会被安装”的报错。针对这个报错从网上弄了好几种设置，也不知道到底哪个是真正奏效的（汗）</p>
<ul>
<li><code>gcc/g++</code>的降级（这个还是很重要的，主要用到<code>update-alternatives</code>命令）</li>
<li>开启Ubuntu软件更新（重要位置和推荐）</li>
<li>用aptitude代替apt-get（但我后来没用deb安装包似乎这一条没什么用了）</li>
</ul>
<p>虽然我的机子是Ubuntu20.04，但最后下载的是CUDA11.4版本且适用于Ubuntu18.04<code>run</code>文件安装成功过的。</p>
<h2 id="cuDNN的安装"><a href="#cuDNN的安装" class="headerlink" title="cuDNN的安装"></a>cuDNN的安装</h2><p>这个就相对好弄多了。</p>
<p>只要先装<code>Runtime Library</code>再装<code>Developer Library</code>和<code>Sample</code>三个安装包即可。</p>
<p>验证成功安装时，将<code>mnistCUDNN</code>的实例拷到个人目录下，然后还得更新一波FreeImage，以及在make的时候sudo一下，Test Passed.</p>
<h2 id="TensorFlow-GPU的安装"><a href="#TensorFlow-GPU的安装" class="headerlink" title="TensorFlow-GPU的安装"></a>TensorFlow-GPU的安装</h2><p>还是用conda来做比较方便。首先换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span><br><span class="line">python oh-my-tuna.py</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.8</span><br><span class="line">pip install -U pip</span><br><span class="line">conda activate tf</span><br><span class="line">pip install -U tensorflow-gpu</span><br></pre></td></tr></table></figure>
<p>差不多就可以了。</p>
<p>最后验证一下即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营5 J Jewels</title>
    <url>/2021/08/01/nowcoder5j/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有$n$个宝石，每个宝石初始位置在$(x_i,y_i,z_i)$。你每一秒可以取一块宝石，消耗体力为宝石到原点距离的平方。每一秒钟宝石位置会变动，$t$秒后变动的位置为$(x_i,y_i,z_i+t\cdot v)$。现在问最少取完所有宝石所消耗的体力。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1\leq n \leq 300\\
1\leq x,y,z,v < 1000</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>很容易分析是考虑</p>
<script type="math/tex; mode=display">
2\sum_{i=1}^nz_iv_i\cdot(i-1)+\sum_{i=1}^n (i-1)^2v_i^2</script><p>的最小值。那么这实际上是一个排列的问题，也就是一个时间与宝石的匹配问题。所以可以考虑二分图X部为时间，Y部为宝石，边权为在这个时间取宝石的代价，跑一个最小权匹配即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 650</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	LL x,y,z,v;</span><br><span class="line">&#125; dat[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">namespace</span> KM &#123;</span><br><span class="line">	LL w[MAXN][MAXN],slack[MAXN],lx[MAXN],ly[MAXN];</span><br><span class="line">	<span class="keyword">bool</span> vis2[MAXN];</span><br><span class="line">	<span class="keyword">int</span> pre[MAXN],match[MAXN];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis2));</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(pre));</span><br><span class="line">		<span class="built_in">memset</span>(slack,<span class="number">63</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(slack));</span><br><span class="line">		<span class="keyword">int</span> x,y=<span class="number">0</span>,yy=<span class="number">0</span>;</span><br><span class="line">		LL d;</span><br><span class="line">		match[<span class="number">0</span>]=p;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			x=match[y];</span><br><span class="line">			vis2[y]=<span class="literal">true</span>;</span><br><span class="line">			d=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vis2[i])<span class="keyword">continue</span>;</span><br><span class="line">				<span class="keyword">if</span>(slack[i] &gt; lx[x]+ly[i]-w[x][i]) &#123;</span><br><span class="line">					slack[i]=lx[x]+ly[i]-w[x][i];</span><br><span class="line">					pre[i]=y;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(slack[i] &lt; d) &#123;</span><br><span class="line">					d=slack[i];</span><br><span class="line">					yy=i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span>(vis2[i])</span><br><span class="line">					lx[match[i]]-=d,ly[i]+=d;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					slack[i]-=d;</span><br><span class="line">			&#125;</span><br><span class="line">			y=yy;</span><br><span class="line">		&#125; <span class="keyword">while</span>(match[y]);</span><br><span class="line">		<span class="keyword">while</span>(y) &#123;</span><br><span class="line">			match[y]=match[pre[y]];</span><br><span class="line">			y=pre[y];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">Max_Match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LL ret=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(lx,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(lx));</span><br><span class="line">		<span class="built_in">memset</span>(ly,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(ly));</span><br><span class="line">		<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(match));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">bfs</span>(i);</span><br><span class="line"><span class="comment">//		for(int i=1; i&lt;=n; i++)printf(&quot;%d %d\n&quot;,match[i],i);</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)ret+=w[match[i]][i];</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld%lld&quot;</span>,&amp;dat[i].x,&amp;dat[i].y,&amp;dat[i].z,&amp;dat[i].v);</span><br><span class="line">		ans+=dat[i].x*dat[i].x+dat[i].y*dat[i].y+dat[i].z*dat[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			KM::w[i][j]=-(<span class="number">1ll</span>*<span class="number">2</span>*(i<span class="number">-1</span>)*dat[j].z*dat[j].v + <span class="number">1ll</span>*(i<span class="number">-1</span>)*<span class="number">1ll</span>*(i<span class="number">-1</span>)*dat[j].v*dat[j].v);</span><br><span class="line">	ans+=-KM::<span class="built_in">Max_Match</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>更改顶标的时候Y部的点0也是要考虑的！</p>
<p>此外最小权匹配就是全部边变成负数时的最大权匹配。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大权匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC, Central Europe Regional Contest (CERC 16) L - Lost Logic</title>
    <url>/2021/08/06/supple3l/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有$n$个布尔变量和三个可行解，现在要求构造不超过$500$条限制条件，使得这些可行解成为在限制条件下仅有的三个可行解。</p>
<script type="math/tex; mode=display">
1 \leq n \leq 50</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题很有意思。</p>
<p>首先这个题有一定的伪装性，让人以为往$2-SAT$​​​上去想,其实跟<code>2-SAT</code>没有半毛钱关系。主要在于<strong>怎么给变量分类，化繁为简</strong>，同时用数理逻辑知识把约束关系表达出来。</p>
<p>因为只有3个可行解，所以所有变量在三个解中的取值无非最多8种。我们把变量分成以下几类：</p>
<p>①全0或全1，那么相当于这个变量的值就是确定的。所以赋值</p>
<script type="math/tex; mode=display">
x \to \lnot x(x=0)\\
\lnot x \to x(x=1)</script><p>②两个变量取值恰好相同，那么$x_1$确定了，$x_2$就确定了，所以赋值</p>
<script type="math/tex; mode=display">
x_1 \to x_2\\
x_2 \to x_1</script><p>③两个变量恰好取值相反</p>
<script type="math/tex; mode=display">
x_1 \to \lnot x_2\\
\lnot x_2 \to x_1</script><p>分析完以上三类情况，我们发现自由变量数目不会超过3个。原因就是一共的8种情况，刨去全0和全1的，剩下6种是对称的。（比如<code>001</code>和<code>110</code>,<code>010</code>和<code>101</code>）</p>
<p>如果只有两个自由变量，那么本来应该可以由4组解，现在给出了3组，所以只需要讨论一下限制死第四组就行。</p>
<p>如果有三个自由变量，那么8种情况剩下5组无论如何也限制不住，就是本题的无解，输出<code>-1</code>.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dat</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">bool</span> val_x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">bool</span> val_y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> constr[<span class="number">3</span>][MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis1[MAXN],vis2[MAXN];</span><br><span class="line">vector&lt;dat&gt; ans;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; fre;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">bool</span> val_x,<span class="keyword">bool</span> val_y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(constr[<span class="number">0</span>][x]==val_x &amp;&amp; constr[<span class="number">0</span>][y]==val_y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(constr[<span class="number">1</span>][x]==val_x &amp;&amp; constr[<span class="number">1</span>][y]==val_y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>(constr[<span class="number">2</span>][x]==val_x &amp;&amp; constr[<span class="number">2</span>][y]==val_y)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;constr[<span class="number">0</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;constr[<span class="number">1</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;constr[<span class="number">2</span>][i]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(constr[<span class="number">0</span>][i]==constr[<span class="number">1</span>][i] &amp;&amp; constr[<span class="number">1</span>][i]==constr[<span class="number">2</span>][i]) &#123;</span><br><span class="line">			vis1[i]=<span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span>(constr[<span class="number">0</span>][i]==<span class="number">1</span>)</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;i,<span class="number">0</span>,i,<span class="number">1</span>&#125;);</span><br><span class="line">			<span class="keyword">else</span> ans.<span class="built_in">push_back</span>(&#123;i,<span class="number">1</span>,i,<span class="number">0</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(vis1[i])<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(!vis2[i])fre.<span class="built_in">push_back</span>(i);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis1[j])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(vis2[i] &amp;&amp; vis2[j])<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(constr[<span class="number">0</span>][i]==constr[<span class="number">0</span>][j] &amp;&amp; constr[<span class="number">1</span>][i]==constr[<span class="number">1</span>][j] &amp;&amp; constr[<span class="number">2</span>][i]==constr[<span class="number">2</span>][j]) &#123;</span><br><span class="line">				vis2[i]=<span class="literal">true</span>,vis2[j]=<span class="literal">true</span>;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;i,<span class="number">1</span>,j,<span class="number">1</span>&#125;);</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;j,<span class="number">1</span>,i,<span class="number">1</span>&#125;);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>(constr[<span class="number">0</span>][i]!=constr[<span class="number">0</span>][j] &amp;&amp; constr[<span class="number">1</span>][i]!=constr[<span class="number">1</span>][j] &amp;&amp; constr[<span class="number">2</span>][i]!=constr[<span class="number">2</span>][j]) &#123;</span><br><span class="line">				vis2[i]=<span class="literal">true</span>,vis2[j]=<span class="literal">true</span>;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;i,<span class="number">1</span>,j,<span class="number">0</span>&#125;);</span><br><span class="line">				ans.<span class="built_in">push_back</span>(&#123;j,<span class="number">0</span>,i,<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> k1,k2;</span><br><span class="line">	<span class="keyword">if</span>(fre.<span class="built_in">size</span>()&gt;=<span class="number">3</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span>(fre.<span class="built_in">size</span>()==<span class="number">2</span>) &#123;</span><br><span class="line">		k1=fre[<span class="number">0</span>],k2=fre[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(k1,k2,<span class="number">0</span>,<span class="number">0</span>))ans.<span class="built_in">push_back</span>(&#123;k1,<span class="number">0</span>,k2,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(k1,k2,<span class="number">0</span>,<span class="number">1</span>))ans.<span class="built_in">push_back</span>(&#123;k1,<span class="number">0</span>,k2,<span class="number">0</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(k1,k2,<span class="number">1</span>,<span class="number">0</span>))ans.<span class="built_in">push_back</span>(&#123;k1,<span class="number">1</span>,k2,<span class="number">1</span>&#125;);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">check</span>(k1,k2,<span class="number">1</span>,<span class="number">1</span>))ans.<span class="built_in">push_back</span>(&#123;k1,<span class="number">1</span>,k2,<span class="number">0</span>&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.<span class="built_in">size</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> t : ans) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t.val_x==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x%d -&gt; &quot;</span>,t.x);</span><br><span class="line">		<span class="keyword">if</span>(t.val_y==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">&quot;!&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;x%d\n&quot;</span>,t.y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>构造</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>（旧文重发）线段树分治</title>
    <url>/2021/08/04/segtreediv/</url>
    <content><![CDATA[<h1 id="线段树分治"><a href="#线段树分治" class="headerlink" title="线段树分治"></a>线段树分治</h1><h3 id="20171202上课时的讲述"><a href="#20171202上课时的讲述" class="headerlink" title="20171202上课时的讲述"></a>20171202上课时的讲述</h3><p>​    以时间为顺序建立一颗线段树，每一个节点开一个$vector$，把一个修改按照其作用区间，$push\;back$到所有“定位”节点上。那么<strong>对于一个询问而言，它所受影响的所有修改一定是从线段树根节点到询问的这篇叶子的所有途径节点</strong>。</p>
<p>​    于是我们对于每一个节点上的修改信息进行整合，再一个一个贡献。如此一来，无论添加还是修改，都只是对应一段作用区间而已。所以最后只要在线段树上$DFS$一次即可.</p>
<p>​    如果有排序操作，最好在区间外面实现有序（排好序）</p>
<p>​    其实线段树分治重要在思想，而是不是以时间为“轴”是不一定，这个应该因题目而灵活选取。</p>
<h4 id="例题一-YZOJ-2758"><a href="#例题一-YZOJ-2758" class="headerlink" title="例题一    YZOJ  2758"></a>例题一    YZOJ  2758</h4><h5 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h5><p>给定一颗树，树的每一条边上有权值上下界（即通过时使用的权值必须在这个上下界的闭区间内，否则无法通过），现在有若干询问，每一个询问给出一个权值$val$,对于每一个询问求一个<strong>最长</strong>的符合上下界要求的简单路径，输出路径的长度。</p>
<h5 id="【分析与解】"><a href="#【分析与解】" class="headerlink" title="【分析与解】"></a>【分析与解】</h5><p>​    我们按照权值作为线段树的“轴”，那么每一个询问对应到线段树的一个叶节点，而修改操作为线段树的一些区间。于是我们可以先把所有的修改和询问在相应的节点上打标记（$vector$中$push\;back$）.</p>
<p>​    关于维护当前连边的最长链。我们用并查集来维护这个关系。但是我们注意到，每一条边只能在回答当前的节点时被使用。所以我们要对于并查集每一步操作记录信息（之前的$fa$，更改后的$fa$诸如此类的），在遍历完整个线段树子树后，进行栈序撤销。</p>
<h3 id="练习一-FJOI-2015-火星商店问题"><a href="#练习一-FJOI-2015-火星商店问题" class="headerlink" title="练习一 FJOI 2015 火星商店问题"></a>练习一 FJOI 2015 火星商店问题</h3><h4 id="【题目描述】-1"><a href="#【题目描述】-1" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>现在要求实现两种事件：<br>       ① $0\; s \;v$​​ 表示第$s$​​个盒子添加了一种价格为$v$​​商品</p>
<p>② $1\; L\; R\; x\; d $表示询问在前后的$d$天内，$[L,R]$的盒子的所有商品中，其价格异或$x$的最大值</p>
<p>每一天先有$0$事件，再有$1$事件</p>
<h4 id="【分析与解】-1"><a href="#【分析与解】-1" class="headerlink" title="【分析与解】"></a>【分析与解】</h4><p>​    通过“可持久化Trie”树的学习，我们知道关于异或最大值这件事可以通过查询$root[L-1]$到$root[R]$中的与$x$的二进制相异的最大的那个“单词”来得到。</p>
<p>​    但是天数是一个范围，也就是说我们相当于树的个数可能是二维的。</p>
<p>​    线段树分治要求询问转化成若干线段树式节点的查询，修改也是如此。</p>
<p>​    于是我们把时间作为线段树的下标“轴”（外部实现），把可持久化$Trie$作为内部实现。</p>
<p>​    对于每一个线段树节点，我们维护两个vector，分别表示<strong>“途径”该节点的所有修改操作的编号</strong>，和<strong>“定位”该节点的所有查询的操作的编号</strong>。</p>
<p>​    在$main$函数中，我们把修改和查询操作依次添加到线段树的相应节点的$vector$中。<strong>注意，修改操作是所有的途径节点，查询操作仅仅在定位节点中添加即可</strong>。在线段树分治函数中，我们先访问大区间，再访问小区间（其实这道题怎么都行，因为所有的节点是独立贡献，顺序无所谓（方法一），但是遇到$DFS$序之类的问题，就必须这么做了（方法二））。然后在每一个节点，先处理修改（依次添加$Trie$树信息），再处理询问，更新答案。</p>
<p>​    复杂度为$O(klog_n)$ 其中$k$是处理每一个修改的复杂度，大概也是什么的$log$。</p>
<h3 id="练习二-TJOI2018-数学计算"><a href="#练习二-TJOI2018-数学计算" class="headerlink" title="练习二 TJOI2018 数学计算"></a>练习二 TJOI2018 数学计算</h3><h4 id="【题目描述】-2"><a href="#【题目描述】-2" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定$mod$，要求对每一个时刻支持两种操作：</p>
<p>① $1 \;m$ ,表示把上一个时刻的数乘上$m$，并输出其对$mod$取模的值</p>
<p>② $2 \;pos$，表示把上一个时刻的数除以第$pos$个时刻乘上的数（保证$pos$时刻执行的1操作），并输出其对$mod$取模的值</p>
<p>数据范围： $Q&lt;=10^5 \; m&lt;=10^9$</p>
<h4 id="【分析与解】-2"><a href="#【分析与解】-2" class="headerlink" title="【分析与解】"></a>【分析与解】</h4><p>​    一定要明白删除时怎么被转换的！就是添加的某个东西的作用域被削减了。</p>
<p>​    所以这道题就是以时间为轴建立线段树，修改对应一个区间，右端点如果有2操作，就是那个时刻-1，否则就是最终时刻。询问就是叶子，然后进行线段树分治即可。</p>
<h3 id="练习三-BZOJ-4025-二分图"><a href="#练习三-BZOJ-4025-二分图" class="headerlink" title="练习三 BZOJ 4025 二分图"></a>练习三 BZOJ 4025 二分图</h3><h4 id="【题目描述】-3"><a href="#【题目描述】-3" class="headerlink" title="【题目描述】"></a>【题目描述】</h4><p>给定一张图$n$个节点$m$条边，每一条边的出现时间为一个区间，问每一段时间是否构成一张二分图。</p>
<p>数据范围：$n&lt;=100000，m&lt;=200000，T&lt;=100000，1&lt;=u,v&lt;=n，0&lt;=start&lt;=end&lt;=T $</p>
<h4 id="【分析与解】-3"><a href="#【分析与解】-3" class="headerlink" title="【分析与解】"></a>【分析与解】</h4><p>二分图有一个重要的性质：</p>
<blockquote>
<p>一个图是二分图，当且仅当图中不包含有长度为奇数的环</p>
</blockquote>
<p>我们按照时间为轴建立线段树，询问为每一个叶子节点，修改为一段区间。那么对于每一次新加入一条边，我们考虑<strong>因为加入了这条边，所造成一个环产生，而这个环是不是奇环</strong>。</p>
<p>我们用并查集来维护边的连通性，由于我们要求两个点的链长，所以不能进行路径压缩，只能进行启发式合并。也就是维护两个并查集的$rank$，小的并入大的，然后求链长就是暴力跳到祖先。</p>
<p>由于我们关心链长的奇偶性，所以我们可以在暴力跳的时候每一次异或连向父亲的链的权值，最后两个值异或再异或上1（表示新添加一条链），如果这个值是偶数，那就是合法的，否则是非法的。</p>
<p>对于一个线段树上节点而言，由于是进行完所有修改再询问，如果一旦某一步发生了非法，则整个区间的询问全部是非法。这种情况下就不必再向下递归了。</p>
<p>然后向下递归执行，到叶节点如果没有被判定非法，就是合法的。</p>
<p>但是这里要支持<strong>栈序撤销</strong></p>
<p>乍一看要可持久化，其实不然。我们只需要记录两种事件：一种是$rank$数组的变更，一种是父亲的变更。</p>
<p>由于我们在并查集合并时一定是祖先合并，所以撤销也就是$fa[x]=x$，在数组中记录更改的下标即可。对于rank，由于更改就是$+1$，所以只需要记录下标，回溯时-1即可。</p>
<p>如何区分两种操作？只需要令一个是正的，一个是负的（妙）。</p>
<p>复杂度是$O(mlogT)$</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 H题</title>
    <url>/2021/07/27/test/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>考虑$x=\prod_{i}p_i^{a_i}$,$y=\prod_{i}p_i^{b_i}$.定义$x \bigotimes y$=$\prod_{i}p_i^{|a_i-b_i|}$,现在给定一个数列$a[1…n]$，求出</p>
<script type="math/tex; mode=display">
b[i]=\sum_{1 \leq j,k \leq n,j \bigotimes k=i}a_jk^c</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先通过$|a_i-b_i|=max(a_i,b_i)-min(a_i,b_i)$来理解这个定义本质是$\frac{lcm(a,b)}{gcd(a,b)}$,故进一步得到</p>
<script type="math/tex; mode=display">
i=\frac{j}{gcd} \cdot \frac{k}{gcd}</script><p>那么不妨令</p>
<script type="math/tex; mode=display">
s=\frac{j}{gcd},t=\frac{k}{gcd}</script><p>故</p>
<script type="math/tex; mode=display">
i=s \cdot t \\(s,t)=1</script><p>因此</p>
<script type="math/tex; mode=display">
b[i]=\sum_s (\frac{i}{s})^c \sum_{gcd} (a_{s \cdot gcd})\cdot gcd^c</script><p>由此可见后面这个$gcd$的部分可以通过对于一个数枚举其倍数预处理得到，其复杂度为</p>
<script type="math/tex; mode=display">
n \cdot \sum_{i=1}^N \frac{1}{i} =nlogn</script><p>前面这个$s$的枚举是$O(n\sqrt n)$,但并不满。因此总复杂度是可以接受的。</p>
<p>此外，对于$s,t$并没有大小之分，但是需要保证$s \cdot gcd ,t \cdot gcd \leq n$,因此需要在上述计算中选择较小的$gcd$上限来运算。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>本题在考场上低级错误在于快速幂。</p>
<p>枚举因子时<code>sqrt</code>应当提前算出！</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">    LL ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL b[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line">vector&lt;LL&gt; rela[MAXN];</span><br><span class="line">LL my_pow[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;H.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    LL now;</span><br><span class="line">    <span class="keyword">int</span> s,t,qrt;</span><br><span class="line">    n=<span class="built_in">mread</span>(),c=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)my_pow[i]=<span class="built_in">quick_pow</span>(i,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,k=<span class="number">1</span>; j&lt;=n; j+=i,k++) &#123; <span class="comment">//gcd enum</span></span><br><span class="line">            now=(now+<span class="number">1ll</span>*a[j]*my_pow[k]%MOD+MOD)%MOD;</span><br><span class="line">            rela[i].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        qrt=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=qrt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            s=j,t=i/j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gcd</span>(s,t)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s!=t) &#123;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[t]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[t][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span>  b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sum=sum^b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu AI 相关软件安装心得 （2）</title>
    <url>/2021/08/02/ubuntuai2/</url>
    <content><![CDATA[<p>这次主要说一说Ubuntu上<code>Jupyter Notebook</code>的使用。</p>
<h2 id="启用Tensorflow的问题"><a href="#启用Tensorflow的问题" class="headerlink" title="启用Tensorflow的问题"></a>启用<code>Tensorflow</code>的问题</h2><p>如果直接打开Jupyter Notebook，会发现No module named ‘Tensorflow’错误。</p>
<p>故首先执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ conda activate tf</span><br></pre></td></tr></table></figure>
<p>然后关闭Jupyter通过Ctrl-C即可。</p>
<h2 id="更改Jupyter-工作路径"><a href="#更改Jupyter-工作路径" class="headerlink" title="更改Jupyter 工作路径"></a>更改Jupyter 工作路径</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ jupyter-notebook --generate-config</span><br></pre></td></tr></table></figure>
<p>此命令执行后，会生成一个<code>.py</code>文件，在此文件中搜寻<code>notebook_dir</code>字段并修改即可。</p>
<h2 id="关于插件：代码补全与格式化"><a href="#关于插件：代码补全与格式化" class="headerlink" title="关于插件：代码补全与格式化"></a>关于插件：代码补全与格式化</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pip install jupyter_contrib _nbextensions</span><br><span class="line">$ jupyter_contrib nbextension install --user --skip_running_check</span><br></pre></td></tr></table></figure>
<p>之后就会发现有了插件</p>
<p>然后<code>Hinterland</code>是代码补全，<code>autopep</code>是代码格式化。 </p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
