<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to LaiAng80586&#39;s Blog！(&gt;ω&lt;*)</title>
    <url>/2021/07/27/about/</url>
    <content><![CDATA[<h2 id="Self-Introduction"><a href="#Self-Introduction" class="headerlink" title="Self Introduction"></a>Self Introduction</h2><p>LaiAng80586</p>
<p>BUAA SCSE 2020</p>
]]></content>
  </entry>
  <entry>
    <title>2021年7月训练</title>
    <url>/2021/07/27/2021%E5%B9%B47%E6%9C%88%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="202107月训练"><a href="#202107月训练" class="headerlink" title="202107月训练"></a>202107月训练</h1><h3 id="CF-1547F"><a href="#CF-1547F" class="headerlink" title="CF 1547F"></a>CF 1547F</h3><p>其实我们已经想到了本质是求<strong>最长的一段不是全局公约数的子序列</strong>长度，而且$O(\sum n)$的提示也容易使人明白需要用类似尺取的方法。但差点意思的是怎么尺取呢？</p>
<p>之前失败的思路，问题在于要考虑的质因数太多，并不能动态维护当前段的所有质因数。所以这时候我们需要估计对于每一个数，其<strong>质因数个数的上限</strong>——其实就是8个，所以一个一个考虑是足够的。那么问题需要转化，也就是首先所有的数都除掉全局公约数，这样就是求最长的一段$gcd&gt;1$的子序列。</p>
<p>那么我们按照线性筛得到的筛法树的边权<strong>（注意严格保存最小质因子）</strong>，容易得到每个数的因数分解，那么对于每一个数$a_i$,枚举它的所有质因数$p$，然后向左向右扩展，每扩展一个数，就把它的$p$从其质因数集合中消去，这样就可以不断更新最大长度。</p>
<p><strong>算法标签</strong> <code>数论</code> <code>线性筛</code> <code>双指针/尺取法</code></p>
<h3 id="CF-1547G"><a href="#CF-1547G" class="headerlink" title="CF 1547G"></a>CF 1547G</h3><p>基本思路是正确的，就是要用SCC来统一处理环。然后1是唯一确定的源点，这个条件很好，使得DFS和Tarjan过程仅从1开始就行。然后从1开始到某点的访问次数，由于只考虑2次以上有限次，所以DFS就可以统计，并不需要DP。最后凡是从1到某个点路径经过SCC（或者自环）的，$ans_i=-1$</p>
<p><code>算法标签</code> <code>图论</code> <code>强连通分量</code></p>
<h3 id="CF-1391D"><a href="#CF-1391D" class="headerlink" title="CF 1391D"></a>CF 1391D</h3><p>这个题其实还是一个奇偶的构造。</p>
<p>首先行数超过4行和行数只有1行的情况很容易处理。那么先考虑两行的情况。这时的偶方阵就是$2 \times 2$的方阵，所以如果有奇数个1，相邻$2\times1$的列的1个数奇偶性应该不同。所以整个矩阵最终效果，就是“奇偶奇偶”的情形，或者”偶奇偶奇”的情形。按照这两种情况扫一遍即可。</p>
<p>那么行数为3的情况怎么样呢？其实这里就是化归，前两行和后两行分别实现$n=2$时奇偶分布，所以是四种情况，同样扫就行。</p>
<p><strong>算法标签</strong> <code>奇偶分析</code></p>
<h3 id="CF-1550D"><a href="#CF-1550D" class="headerlink" title="CF 1550D"></a>CF 1550D</h3><p>这题核心在于一个偏移量的思想。设置$a_i=i+k_i$然后分析$k_i$的性质，来计数。具体思路见题解。</p>
<p><img src="https://tva1.sinaimg.cn/large/0066rFaply8gsvgpc69s5j30wb0ldjyg.jpg" alt="image-20210718152335714"></p>
<h3 id="CF-1550F"><a href="#CF-1550F" class="headerlink" title="CF 1550F"></a>CF 1550F</h3><p>这个题目很综合，也体现<strong>建图和图的处理的</strong>一些技巧。</p>
<p>首先怎么考虑每一次$[d-k,d+k]$这个范围的跳跃的构建。其实最<strong>朴素的想法</strong>是枚举两个节点，连接一条边，边权就是坐标差的绝对值。那么适配这个题目，就再把$d$考虑进去，变成$w=|d-|a_u-a_v||$。所以如果从$s$到$i$经过的若干边，他的边权$w$都不超过$k$，那么就是满足要求的。</p>
<p>考虑到每一次的$k$是变动的，$k$越大，相当于跳跃的约束越小。因此我们就考虑尽可能用$w$的边来构成从$s$到$i$的路径，这样就可以更大化地满足要求苛刻的$k$。于是我们可以考虑<strong>求一棵最小生成树</strong>。</p>
<p>但是个$n^2$量级的完全图，因此普通的Kruskal和Prim是不行的。我们用一个新算法——$Boruvka$。</p>
<p>Boruvka 算法的一句话思想便是：</p>
<p>“从<em>所有当前的连通块向其他连通块<strong>扩展出最小边</strong></em>，直到只剩一个连通块”，其中取最小边的贪心思想是 Kruskal 的主体，而向外扩展又是 Prim 的思想 —— 基于另外两种生成树算法，Boruvka 的正确性显然。</p>
<p>其代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 连通块个数&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        mn[i] = 连接 i 与其他连通块的最小边</span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        <span class="keyword">if</span> mn[i] 连接两个不同的连通块</span><br><span class="line">            ans += mn[i]</span><br><span class="line">            <span class="built_in">Merge</span>( mn[i] 连接的连通块 )</span><br><span class="line">            连通块个数 --</span><br></pre></td></tr></table></figure>
<p>而不同的题目难点就在于快速计算$mn_i$。对于这道题而言，其实$mn_i$就是要找到可以向其他连通块扩展的权值在$[a_i-d,a_i+d]$范围内的最小边。<strong>那么我们可以利用<code>set</code>+<code>lower_bound</code>来求这个最小边</strong>。</p>
<p>所以求得最小边后，就用vector维护的并查集来合并（小并入大）维护连通块，同时在新图上连接无向边。</p>
<p>运行完Boruvka算法后，再从$s$出发DFS遍历整个MST，求得它到其他点路径上的权值最大值。最后处理询问时只需要考虑这个权值最大值是不是比k来的小就行了。</p>
<p>复杂度$O(nlog^2n)$</p>
<p>算法标签 <code>最小生成树</code> <code>启发式合并</code> <code>图论建图</code></p>
<h3 id="CF-1550E"><a href="#CF-1550E" class="headerlink" title="CF 1550E"></a>CF 1550E</h3><p>这道题核心在于<strong>模拟匹配</strong>。</p>
<p>从<a href="https://frozenguardian.blog.csdn.net/">Frozen_Guardian</a>的博客上学到了关于这种<strong>状压</strong>的一些真知灼见。</p>
<blockquote>
<p>状压$dp$就是全排列问题的一种优化，所以状压$dp$可以解决的问题，全排列暴力枚举肯定也是可以解决的。所以先将问题简化，假设本题放开全排列该如何去做？</p>
</blockquote>
<p>我们要全排列什么？其实相当于<strong>从左到右依次放置待判定长度的相同字母子串</strong>。所以问题的关键就在于判别不同排列时能不能恰好匹配？所以这里就借助了序列自动机的概念。我们记$nnext[i][j]$表示从字符串第$i$个字符开始，其<strong>最早</strong>完全匹配第$j$种字符的待判定长度的字串时，下一个位置是多少？那么计算就是从后往前计算，如果借助？和已有的字母能够新增出一个完全的匹配，那么就赋值，否则照搬$nnext[i+1][j]$。</p>
<p>再考虑$dp$的转移，很容易想到$dp[mask]$就是已经使用字母的状态，这个dp值的含义是完成状态内这些字母的匹配后，<strong>最小的下一个位置</strong>（相当于一个$end$指针）。所以说我们其实并不关心从左到右到底是如何安排的，只需要按照$nnext$来辅助转移就可以了。</p>
<p>所以最后的判定标准就是如果$dp[2^k-1]$在$n-1$范围内，就是可以的。主函数二分答案即可。</p>
<p><strong>算法标签</strong> <code>二分答案</code> <code>序列自动机</code> <code>状压DP</code></p>
<h2 id="Nowcoder-Summer-2"><a href="#Nowcoder-Summer-2" class="headerlink" title="Nowcoder Summer 2"></a>Nowcoder Summer 2</h2><h3 id="J-Product-of-GCDs"><a href="#J-Product-of-GCDs" class="headerlink" title="J Product of GCDs"></a>J Product of GCDs</h3><p>给定一个集合，求其所有大小为$k$的子集的$gcd$之积</p>
<p>基本思路在赛场上就讨论的很清楚了，事后看题解也大致是这个思路。但赛场上没写出来的原因，是欧拉函数不会求。</p>
<p>把所有的数按照<strong>所含的质因子分类</strong>，朴素来说就是每一个质数开一个桶，把凡是含有这个质因子的数往这个桶里装，然后这个桶不断的处理该质因子的若干次幂的情况，相当于每一次把桶里所有数除一遍这个质数，然后删掉不再含有该质因子的数，每一次操作后对桶的大小做一个组合数的快速幂：</p>
<script type="math/tex; mode=display">
ans \gets prime^{C_{size}^k}</script><p>这个组合数数值很大，难以存储，又考虑这个组合数在指数的位置上，所以先求出$\varphi(p)$,然后用公式$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$来递推取模得到所需的组合数，对一组数据复杂度为$O(nk)$</p>
<p>此外关于实现，其实朴素想法中的“桶”是不需要用<code>STL​</code>的什么容器来实现的。只需要每次枚举质数和质数的幂次即可。因为用了容器，反而会多出来一些复杂度。</p>
<p><strong>算法标签</strong> <code>欧拉函数</code> <code>组合数</code> </p>
<h3 id="G-League-of-Legends"><a href="#G-League-of-Legends" class="headerlink" title="G League of Legends"></a>G League of Legends</h3><p>将$n$条线段分成$k$组，每组线段求一个交，求最大化所有交之和。</p>
<p>其实这个分组问题很容易想到的是用DP解法。那么DP解法我们不能<strong>枚举</strong>分组情况，从经验而言，一般是考虑<strong>连续的一系列线段</strong>构成最后一组这样子。那么怎么做才能使这样的DP成立呢？</p>
<p>首先我们把线段分成两类：一类线段可以包含其他的线段。那么如果把这个线段和其所包含的线段安排在一组，则不会对答案有新的贡献，要么把它单独分组，贡献其长度。另一类线段就是相互之间均不能包含，但可以有相交的部分。我们考虑把这些线段按左端点从小到大排序，那么右端点一定是单调不降的。这个时候，我们分析贪心，在这些线段中分组，一定是把连续的线段分成一组。因为通过画图可以知道，如果把排序后两条不相邻$i$,$j$的线段分成一组，那么我们取$k,i &lt;k&lt;j$，就会发现无论是$(i,k)$一组还是$(k,j)$一组，对答案的贡献都比$(i,j)$一组来的多。当然这里还有一个显然的事情就是一个组的线段越多，相交部分肯定倾向于越少。</p>
<p>于是我们就有了DP方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=max_{k<i}\{dp[k][j-1]+R[k+1]\}-L[i],R[k+1] \geq L[i]</script><p>其中，$dp[i][j]$表示把第二类线段的前$i$条线段分成$j$组的最优情况。</p>
<p>那么这个方程我们可以用单调队列优化。</p>
<p>复杂度为$O(n^2)$</p>
<p><strong>算法标签</strong> <code>递推与动规</code> <code>贪心</code> <code>单调队列</code></p>
<h2 id="数论知识回顾"><a href="#数论知识回顾" class="headerlink" title="数论知识回顾"></a>数论知识回顾</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>基本定义：对于一个正整数$n$,$\varphi(n)$代表比$n$小的且与$n$互质的正整数的个数。</p>
<p>计算性质：</p>
<script type="math/tex; mode=display">
\varphi(n)=\begin{cases}
n-1,&\text{n is a prime}\\
(p-1)p^{k-1},& n=p^k,\text{p is a prime}\\
\varphi(s)\cdot \varphi(t),&\text{n=st and (s,t)=1}\\
\varphi(k) ,&n=2k,\text{k is an odd}
\end{cases}</script><p>定义式：</p>
<script type="math/tex; mode=display">
\varphi(n)=n \cdot \prod_{i=1}^k (1-\frac{1}{p_i})</script><p>其中，$p_i$是$n$的质因子。</p>
<h3 id="判断质数的方法：Miller-Rabin"><a href="#判断质数的方法：Miller-Rabin" class="headerlink" title="判断质数的方法：Miller  Rabin"></a>判断质数的方法：Miller  Rabin</h3><h3 id="大整数质因数分解（探寻其质因子）-Pollard-Rho"><a href="#大整数质因数分解（探寻其质因子）-Pollard-Rho" class="headerlink" title="大整数质因数分解（探寻其质因子） Pollard Rho"></a>大整数质因数分解（探寻其质因子） Pollard Rho</h3><h3 id="特殊情况的组合数取模-Lucas"><a href="#特殊情况的组合数取模-Lucas" class="headerlink" title="特殊情况的组合数取模 Lucas"></a>特殊情况的组合数取模 Lucas</h3><script type="math/tex; mode=display">
C_n^m \equiv C_{n/p}^{m/p}\cdot C_{n \;mod\;p}^{m\;mod\;p}\;(mod \;p),\text{p is a prime}</script><h2 id="单调队列优化DP"><a href="#单调队列优化DP" class="headerlink" title="单调队列优化DP"></a>单调队列优化DP</h2><p>题目比如参考上面的G题</p>
<p>这个题的特点是左端点是单调不降的，右端点也是单调不降的。因此我们的单调队列里存下标值，比较的条件是$dp[k][…]+R[k+1]$,限制的条件是$R[k+1] \geq L[i]$,假设当前正在考虑第$i$条线段。</p>
<p>这个单调队列不适合用<code>STL</code>，原因是它两端都要删除添加，还是用数组手写比较方便。</p>
<p>从<strong>队首到队尾</strong>，<code>dp+R</code>这个值<strong>单调递减</strong>，同时下标是<strong>单调递增</strong>的。原因：分同样多的组，当我们可用的线段更多时，方案数更丰富，因此可以得到更好的答案。</p>
<p>二重循环第一重是考虑第几条线段，第二重是考虑分几组。而且需要注意的是，分几组要<strong>从大到小</strong>来，因为处理完第$i$条线段的信息时，第$i$条线段对应的<code>dp+R</code>也会更新到这一系列队列中，对于同样是$i$而分更多组的计算造成干扰（避免后效性）。</p>
<p>队列操作：每一次先在<strong>队首</strong>剔除掉虽然<code>dp+R</code>很大，但不满足$R[k+1]\geq L[i]$的元素，然后算出当前的$dp$值，再在<strong>队尾</strong>更新，把原本队尾<code>dp+R</code>更小的剔除掉。因为这些决策点下标又小，又不利于贡献后面的答案。</p>
<h2 id="Vector的简易写法和for的C-0x用法"><a href="#Vector的简易写法和for的C-0x用法" class="headerlink" title="Vector的简易写法和for的C++0x用法"></a>Vector的简易写法和for的C++0x用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(n);  <span class="comment">//使得其大小为n，访问[0,n-1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//大小为n的vector，访问同上</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">7</span>)</span></span>;<span class="comment">//一个元素，值为7</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : comp)   <span class="comment">//x为comp容器的遍历器，下面直接访问x如何</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:&#123;-d,d&#125;)<span class="comment">//数值范围内遍历</span></span><br><span class="line"><span class="comment">//如果是vector&lt;vector &lt;xxx&gt; &gt; Q；这样的二维vector情形，则考虑</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;comp : comps) &#123;  <span class="comment">//不过遇事不决用auto 就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>1、<code>vector</code>的<code>size</code>是<code>unsigned int</code>类型。</p>
<p>2、STL Vector可能有重分配地址,*it 遍历器可能失效.</p>
<h2 id="计算几何学习"><a href="#计算几何学习" class="headerlink" title="计算几何学习"></a>计算几何学习</h2><p>见手写笔记</p>
<h2 id="编码细节"><a href="#编码细节" class="headerlink" title="编码细节"></a>编码细节</h2><p>1、<code>unsigned long long</code> 用<code>printf</code>输出时控制符为$\%llu$</p>
<p>2、最小值的预命令形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<p>3、Windows 命令行屏幕输出文字： <code>echo</code>+文字内容（不用引号）</p>
<p>4、LL的溢出，考虑用(__int128)或者慢速乘来解决。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__int128)a*b%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还要注意乘除的顺序，必要的时候先除后乘。</p>
<p>两个<code>int</code>相乘在<code>long long</code>的范围内判定，简单明确的写法是<code>1LL*i*j&gt;N</code>这类。</p>
<p>5、取模简化运算：预命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod1(x) (x&gt;=MOD)&amp;&amp;(x-=MOD)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 B</title>
    <url>/2021/07/27/2021Nowcoder4A/</url>
    <content><![CDATA[<h2 id="A-Course"><a href="#A-Course" class="headerlink" title="A Course"></a>A Course</h2><p><strong>生成函数</strong>来计数不同课的选择方案</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n x^i = \frac{1}{1-x^n}\\
f_i(x) =\prod_{i \to j}  f_j...</script><h2 id="B-Sample-Game"><a href="#B-Sample-Game" class="headerlink" title="B Sample Game"></a>B Sample Game</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>有一个随机数生成器可以生成$[1,n]$中所有数，每个数被生成的概率为$p_i$,该生成器如果生成的数均不小于之前生成的所有数，则继续生成，否则停止。记每一轮一共生成了$x$个数，则收益为$x^2$。问期望收益。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">
1 \leq n \leq 100</script><h3 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h3><p>这个题巧妙之处在于对长度发生概率的<strong>设而不求</strong>。</p>
<p>首先我们根据题意知道除了最后一个数之外，该生成序列是单调不降的。那么一旦我们知道了每一个数被生成了多少次，则生成序列唯一确定。因此我们可以用<strong>生成函数</strong>来描述这个期望。</p>
<p>注意到对于一种数，它的被生成的无限期望为</p>
<script type="math/tex; mode=display">
E(\infty)=\sum_{i=1}^{\infty}p_s^i \cdot x_s^i=\frac{1}{1-p_sx_s}</script><p>因此从<strong>序列长度</strong>为1到长度为无穷的期望组合的描述如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=\sum_{i=1}^{\infty} \big(\sum_{s_1+s_2+...+s_n=i} \prod_{k=1}^n p_k^{s_k}) \cdot x^i\\
&=\sum_{i=1}^{\infty}P(len>i)x^i\\
&=\prod_{i=1}^n (1+p_ix_i+p_i^2x_i^2+...+p_i^{\infty}x_i^{\infty})\\
&=\prod_{i=1}^n \frac{1}{1-p_ix}
\end{aligned}</script><p>但这个描述的目的只是间接的得到概率的关系，我们还是得考虑具体的期望公式，再设法往上面得到的这个$f(x)$上转化。</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=\sum_{i=0}^{\infty}\big(P(len>i) -P(len>i+1))\cdot i^2\\
&展开后按照P(len>i)合并项得到\\
&=\sum_{i=0}^{\infty}P(len>i)[(i+1)^2-i^2]\\
&=\sum_{i=0}^{\infty}P(len>i)(2i+1)\\
&=2\cdot f'(1)+f(1)
\end{aligned}</script><p>下面再考虑求$f’(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
令g_i(x)&=\frac{1}{1-p_ix}\\
则g_i'(x)&=\frac{p_i}{(1-p_ix)^2}\\
故f'(x)&=\sum_{i=1}^{n}g_i'(x)\cdot \prod_{j \not=i}g_j(x)\\
&=f(x)\cdot \sum_{i=1}^n \frac{p_i}{1-p_ix}
\end{aligned}</script><p>故答案就是</p>
<script type="math/tex; mode=display">
\big(1+2\cdot\sum_{i=1}^n \frac{p_i}{1-p_i})f(1)</script>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>概率</tag>
        <tag>设而不求</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) Buggy Robot</title>
    <url>/2021/07/30/gym101201B/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有个机器人在一个网格中靠执行一串<code>LRUD</code>指令行动，但这串指令有问题，并不能保证机器人一定能从起点走到终点。当机器人执行一条指令可能出界或遇到障碍，则相当于这条指令无效。而一旦机器人到达了终点，则之后未执行的指令都不用执行。现在问在原串上最少增添多少条指令，可以使机器人从起点到达终点。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m,k \leq 50</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>看到字符串就想匹配，有些狭隘了。确实有匹配的因素，但我们关心的是<strong>从一个字符到下一个字符的转移</strong>，而并非事先构造出整个串。其实我们<strong>并不关心具体增添那些</strong>指令，只关心最小增添的<strong>个数</strong>。而增添的情形，实际上是由坐标来决定的。</p>
<p>因此我们记$dp[i][j][k]$表示当前机器人位于$(i,j)$，即将执行第$k$​条指令时，​达到此状态最小的增添指令次数。那么其实还是枚举四个方向的情形，如果恰好枚举的方向和指令方向一致的话，就去更新$(i’,j’,k+1)$状态的dp值，否则相当于到了下一个点还是执行第$k$条指令。</p>
<p>复杂度为$O(nmk)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>],cmd[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,k;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((x&gt;=<span class="number">1</span>) &amp;&amp; (x&lt;=n) &amp;&amp; (y&gt;=<span class="number">1</span>) &amp;&amp; (y&lt;=m) &amp;&amp; mp[x][y]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;U&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> dy[<span class="number">4</span>]= &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//rows &amp; cols</span></span><br><span class="line">	node now,nxt;</span><br><span class="line">	<span class="keyword">int</span> cmd_go;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">					i,j,<span class="number">1</span></span><br><span class="line">				&#125;);</span><br><span class="line">				dp[i][j][<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//字符串标号 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		now=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		printf(&quot;%d %d %d val=%d\n&quot;,now.x,now.y,now.k-1,dp[now.x][now.y][now.k]); </span></span><br><span class="line"><span class="comment">//		system(&quot;PAUSE&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(mp[now.x][now.y]==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,dp[now.x][now.y][now.k]);  <span class="comment">//可以不执行完既定的指令</span></span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">//!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">			nxt.x=now.x+dx[i];</span><br><span class="line">			nxt.y=now.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(now.k&lt;=len)</span><br><span class="line">				cmd_go=<span class="built_in">num</span>(cmd[now.k]);</span><br><span class="line">			<span class="keyword">else</span> cmd_go=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(nxt.x,nxt.y)) &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//This is an invalid direct.</span></span><br><span class="line">						<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>]==INF)</span><br><span class="line">							Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">							now.x,now.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[now.x][now.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line"><span class="comment">//					printf(&quot;??\n&quot;);</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//No need to add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;<span class="comment">//Guaranteed that len will not be exceeded.</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] &gt; dp[now.x][now.y][now.k] + <span class="number">1</span>) &#123; <span class="comment">//add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k</span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k]=dp[now.x][now.y][now.k] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;B.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;B-1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd+<span class="number">1</span>);</span><br><span class="line">	len=<span class="built_in">strlen</span>(cmd+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">63</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,0x3f3f3f3f);</span></span><br><span class="line">	ans=INF;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,dp[0][0][0],ans);</span></span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>递推与动归</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) D Contest Strategy</title>
    <url>/2021/07/30/gym101201d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>你正在参加一场ACM比赛。已知自己每个题解决的用时。现在你随机开了$k$道题，然后找用时最短的做了，然后再随机开一道，再选用时最短的做了。现在考虑所有开题顺序$n!$中可能，求所有情况的罚时总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq k<n\leq 300</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这个题求解真是<strong>构造和分析小数据</strong>起了很大的作用。“随机”并不可怕，只要把情况都考虑全了就没有问题。</p>
<p>首先说一些简单的性质。就是我们可以记$f[i][j]$​表示第i个题是第j个做的（注意不是开是做！）。那么很显然可以给答案贡献$f[i][j] \cdot t[i]\cdot(n-j+1)$。所以问题转化为怎么求解$f[i][j]$.</p>
<p>我们不妨看几个例子。令$k=5$​比如下面几个状态的4号题（用时也是4个单位时间）前两个第4个做的，第三组是第3个做的：</p>
<script type="math/tex; mode=display">
\text{1 2 8 9 10} \; \underline{4} \;\text{3 5}\\
\text{1} \; \underline{4} \;\text{8 9 10 2 3 5}\\
\text{6 7 8 9 10 5} \; \underline{4} \; 3</script><p>我们从中发现几件事：</p>
<p>为了方便，我们把题目按照解决用时从小到大排序。</p>
<p>首先，如果$i$号题是第$j$个做的，那么到这个题做的时候，已经开了$k-1+j$​个题。而且当这个题做的时候，此时<strong>开了且没做</strong>的题目一定是用时比这个题长的。</p>
<p>令$r=min(k-i+j,n)$​表示已经开了的题数目，$l$为已经开了的题目中用时比这个题短的。</p>
<p>因此$f[i][j]$​一定包含乘积项$A_{n-i}^{r-1-l}$</p>
<p>那么回到上面举的例子，很有可能某个题先开了，但是过了几轮才做，这是因为一直存在比它用时小的题目。所以我们要在计数中枚举比它用时短的题目及其排列，所以$f[i][j]$包含乘积项$A_{i-1}^{l}$</p>
<p>由于题目要求<strong>开题都是有序</strong>的（$n!$​​种情况），因此我们枚举这道题是什么时候开的，以及<strong>比他用时短的题目</strong>都分别是什么时候开的，因此答案会有乘积项$r \cdot C_{r-1}^{l}$</p>
<p>最后我们再考虑这个题目解决后剩下题目的解决顺序，有乘积项$(n-r)!$</p>
<p>这样我们就得到</p>
<p>$f[i][j]=\sum_{l=0}^{j}r\cdot C_{r-1}^{l} \cdot A_{i-1}^{l}\cdot A_{n-i}^{r-1-l} \cdot(n-r)!$</p>
<p>但是我们立刻会发现问题，就是在枚举这个题开题和比他用时短的题目开题顺序时其实并不能这样直接用组合数算，因为这样有些情况导致$i$号题<strong>提前做了</strong>。但是我们发现这样的枚举，总是可以保证$i$号题是前$j$个被解决的题。因此我们修改$f[i][j]$​的含义是<em>第i个题是前j个做的</em>，最后再容斥一下用$f[i][j]-f[i][j-1]$去贡献答案即可。</p>
<p>复杂度为$O(n^3)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">mread</span></span>() &#123;</span><br><span class="line">	int ret=0,f=1;</span><br><span class="line">	char c=getchar();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=-1;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*10+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=getchar();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="built_in">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line">typedef long long LL;</span><br><span class="line">LL combo[330][330];</span><br><span class="line">LL t[330],ans=0;</span><br><span class="line">int n,k;</span><br><span class="line">const int MOD=1e9+7;</span><br><span class="line">LL CC(int n,int m) &#123;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;0 || n&lt;m || m&lt;0)<span class="built_in">return</span> 0;</span><br><span class="line">	<span class="built_in">return</span> combo[n][m];</span><br><span class="line">&#125;</span><br><span class="line">LL f[330][330];</span><br><span class="line">LL fac[330];</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	int r;</span><br><span class="line">	LL tmp,cnt;</span><br><span class="line">	n=mread(),k=mread();</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)t[i]=mread();</span><br><span class="line">	sort(t+1,t+n+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=0; i&lt;=n; i++)combo[i][0]=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++)</span><br><span class="line">			combo[i][j]=(combo[i-1][j]+combo[i-1][j-1])%MOD;</span><br><span class="line">	fac[0]=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)fac[i]=1ll*fac[i-1]*i%MOD;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++) &#123;</span><br><span class="line">			r=min(j+k-1,n);</span><br><span class="line">			<span class="keyword">for</span>(int l=0; l&lt;j; l++) &#123;</span><br><span class="line">				f[i][j]=(f[i][j]+1ll*r*CC(i-1,l)%MOD*CC(r-1,l)%MOD*fac[l]%MOD*CC(n-i,r-1-l)%MOD</span><br><span class="line">				         *fac[r-1-l]%MOD*fac[n-r]%MOD+MOD)%MOD;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int i=1; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(int j=1; j&lt;=n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cnt=f[i][j]-f[i][j-1]+MOD;</span><br><span class="line">			ans=(ans+1ll*t[i]*(n-j+1)%MOD*cnt%MOD+MOD)%MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h2><p>注意题目用时可能一样，但实际上是不同的题目。这里确实是在$A_{i-1}^l$步有问题，但是可以通过容斥来弥补。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) J - Shopping</title>
    <url>/2021/07/30/gym101201j/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>$n$个数的数列 $a_n$​ ,$q$次询问。</p>
<p>每次询问给出数$v$，区间端点$[l，r]$,问用$v$按顺序依次对数列$[l,r]$中的数取模，得到的最终答案。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,q \leq 2 \cdot 10^5\\
1 \leq a_i,v \leq 10^{18}</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这道题在考场上试图通过主席树+二分来解，可惜复杂度为$O(qlog^21e18log^2n)$常数大得离谱。故失败。</p>
<p>首先我们注意到一点，就是每一次取模，这个$v$都会减小一半，因此直接取模最多$log1e18$​求解是可行的。关键在于每次精确的找到对哪个数取模？实际上，就是求对于当前这个数，在它右边最近的小于等于它的数的位置。</p>
<p>这里之前用主席树做麻烦了，其实把上面这句话<strong>翻译</strong>下，不就是<strong>该数$x$向右延伸最多能延伸多少遇到的都是$&gt;x$​​的数</strong>？这件事就转化为一个区间最小值的问题了。而且为了更好的解决延伸，其实用ST表和倍增思路就一步到位了。</p>
<p>实现见代码。</p>
<p>复杂度为$O(qlogn \cdot log10^{18})$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 200100</span></span><br><span class="line">LL mmin[MAXN][<span class="number">25</span>];</span><br><span class="line">LL a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL v;</span><br><span class="line">	<span class="keyword">int</span> l,r,now;</span><br><span class="line">	n=<span class="built_in">mread</span>(),q=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		a[i]=<span class="built_in">mread</span>();</span><br><span class="line">		mmin[i][<span class="number">0</span>]=a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">25</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=n; j++)</span><br><span class="line">			mmin[j][i]=<span class="built_in">min</span>(mmin[j][i<span class="number">-1</span>],mmin[j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(q--) &#123;</span><br><span class="line">		v=<span class="built_in">mread</span>(),l=<span class="built_in">mread</span>(),r=<span class="built_in">mread</span>();</span><br><span class="line">		now=l;</span><br><span class="line">		<span class="keyword">while</span>(now&lt;=r) &#123;</span><br><span class="line">			v=v%a[now];</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">25</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">				<span class="keyword">if</span>(now+(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>&lt;=r &amp;&amp; mmin[now][i]&gt;v)</span><br><span class="line">					now+=((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>);<span class="comment">//应落到可控范围内</span></span><br><span class="line">			now++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>2016 Pacific Northwest Region Programming Contest—Division 1 K Tournament Wins</title>
    <url>/2021/07/30/gym101201k/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>某人参加一场淘汰赛，实力排名为$r$，排名越高实力越强。一共有$2^k$支队伍参加比赛，问这个人获胜场次的概率。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq k \leq 20 \\
1 \leq r \leq 2^k</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这题还是一个要画画图，不能干想。其实把那张满二叉树的晋级图画出来，就明白是怎么回事了。</p>
<p>其实从图上显然看出，某人如果要至少赢$i$​​​场，则应该战胜$2^i-1$个对手。这其实和线段树求区间最小值的原理是类似的。因此可以得到概率</p>
<script type="math/tex; mode=display">
s[i]=\frac{C_{2^k-r}^{2^i-1}}{C_{2^k-1}^{2^i-1}}</script><p>设$f(i)$表示恰好赢$i$场的概率，那么答案</p>
<script type="math/tex; mode=display">
\begin{aligned}
ans&=1\cdot f(1) + 2\cdot f(2)+...n\cdot f(n)\\
&=s[1]+s[2]+...+s[n]
\end{aligned}</script><p>这里值得一提的是怎么快速计算$s[i]$，答案是取对数。</p>
<p>即</p>
<script type="math/tex; mode=display">
s[i]=e^{ln(C_{2^k-1}^{2^i-1})-ln(C_{2^k-r}^{2^i-1})}\\</script><p>而</p>
<script type="math/tex; mode=display">
ln(x!)=ln((x-1)!)+ln(x)</script><p>因此只要预处理即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r,k;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">double</span> my_pow[N],s[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">lnc</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> my_pow[n] - my_pow[m] - my_pow[n-m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,now;</span><br><span class="line">	<span class="keyword">double</span> ans=<span class="number">0.0</span>;</span><br><span class="line">	k=<span class="built_in">mread</span>(),r=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(<span class="number">1</span>&lt;&lt;k); i++)my_pow[i]=my_pow[i<span class="number">-1</span>]+<span class="built_in">log</span>((<span class="keyword">double</span>)<span class="number">1.0</span>*i);</span><br><span class="line">	n=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		now=(<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(n-r &lt; now)<span class="keyword">continue</span>;</span><br><span class="line">		s[i]=<span class="built_in">exp</span>(<span class="built_in">lnc</span>(n - r,now) - <span class="built_in">lnc</span>(n - <span class="number">1</span>,now));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=k; i++)</span><br><span class="line">		ans+=s[i];</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%.5lf\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1)  G - Maximum Islands</title>
    <url>/2021/07/30/gym101201g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给一张表格，表格上<code>L</code>代表陆地，<code>W</code>代表水域,<code>C</code>代表未知（可以使陆地也可以使水域）。现在可以将C区域变成陆地或水域，问最多陆地的连通块有多少块？</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m\leq 40</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先贪心上应该把L周围的区域变成水域，然后再考虑剩下的C点。我们希望尽可能多的填上L，因此最好相邻的格子填不同的区域。</p>
<p>所以问题就转化成一个二分图求最大独立集的问题（见下文）。考虑将原表格从上到下从左到右黑白染色划分格子的归属（说白了就是行号和列号奇偶性相同为黑色，不同为白色），然后对于C点相邻连边，跑最大匹配即可。</p>
<p>最后答案就是原本贪心后已有的L连通块个数 + C点数 - 最大匹配数。</p>
<h2 id="图论相关概念回顾"><a href="#图论相关概念回顾" class="headerlink" title="图论相关概念回顾"></a>图论相关概念回顾</h2><p><code>独立集</code>：无向图点集的一个子集，其中<strong>任意两点不相连</strong>。</p>
<p><code>匹配</code>：无向图边的一个子集，该子集<strong>任意两条边没有公共顶点</strong>且没有自环 </p>
<p><code>顶点覆盖</code>：无向图点集的子集，使得边集中任意一条边都至少有一个点在该子集中。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>|最小顶点覆盖| + |最大独立集| = |V|</p>
<p>在<strong>二分图</strong>中，最小顶点覆盖 = 最大匹配，因此最大独立集 = 点数 - 最大匹配数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,u,v);</span></span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>]= &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">45</span>][<span class="number">45</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">1</span>&lt;=x &amp;&amp; x&lt;=n &amp;&amp; <span class="number">1</span>&lt;=y &amp;&amp; y&lt;=m)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	vis[x][y]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">		nx=x+dx[i],ny=y+dy[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny) &amp;&amp; !vis[nx][ny] &amp;&amp; mp[nx][ny]==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">			<span class="built_in">dfs</span>(nx,ny);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; lef,rig;</span><br><span class="line"><span class="keyword">int</span> connect[<span class="number">2000</span>],state[<span class="number">2000</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(state[v]==<span class="number">0</span>) &#123;</span><br><span class="line">			state[v]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(connect[v]==<span class="number">0</span> || <span class="built_in">match</span>(connect[v])) &#123;</span><br><span class="line">				connect[v]=u;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> now : lef) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(state,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(state));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">match</span>(now))</span><br><span class="line">			sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> nx,ny;</span><br><span class="line">	n=<span class="built_in">mread</span>(),m=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;L&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">4</span>; k++) &#123;</span><br><span class="line">					nx=i+dx[k],ny=j+dy[k];</span><br><span class="line">					<span class="keyword">if</span>(<span class="built_in">check</span>(nx,ny) &amp;&amp; mp[nx][ny]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">						mp[nx][ny]=<span class="string">&#x27;W&#x27;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=n;i++)printf(&quot;%s\n&quot;,mp[i]+1);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;L&#x27;</span> &amp;&amp; !vis[i][j]) &#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="built_in">dfs</span>(i,j);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,ans);</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]!=<span class="string">&#x27;C&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">			ans++;</span><br><span class="line">			<span class="keyword">if</span>((i^j) &amp; <span class="number">1</span>)lef.<span class="built_in">push_back</span>((i<span class="number">-1</span>)*m+j);</span><br><span class="line">			<span class="keyword">else</span> rig.<span class="built_in">push_back</span>((i<span class="number">-1</span>)*m+j);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i,j+<span class="number">1</span>) &amp;&amp; mp[i][j+<span class="number">1</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">				<span class="built_in">addedge</span>((i<span class="number">-1</span>)*m+j,(i<span class="number">-1</span>)*m+j+<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">check</span>(i+<span class="number">1</span>,j) &amp;&amp; mp[i+<span class="number">1</span>][j]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">				<span class="built_in">addedge</span>((i<span class="number">-1</span>)*m+j,i*m+j);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	for(auto x : lef)printf(&quot;%d &quot;,x);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//	for(auto x : rig)printf(&quot;%d &quot;,x);</span></span><br><span class="line"><span class="comment">//	printf(&quot;\n&quot;);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans-<span class="built_in">hungary</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图最大权匹配KM算法介绍</title>
    <url>/2021/08/01/km/</url>
    <content><![CDATA[<h1 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h1><p><code>完备匹配</code> ： X点集所有的点都参与了匹配。</p>
<p><code>可行边</code> ： $lx[i]+ly[j] \geq w[i][j]$的边</p>
<p><code>相等子图</code> ：包含所有点和<strong>可行边</strong>的子图。</p>
<p><code>顶标</code> ： $lx[i],ly[j]$​,人为赋值的点权，为了控制可行边而设立。</p>
<p><code>松弛量</code> ：$\forall i \in Y,slack[y]=min(lx[x]+ly[i]-w[x][i])$</p>
<p><code>顶标修改量</code> ： $d=min(slack[y])$</p>
<p>需要注意的是，松弛量和顶标修改量都是针对当前没有被匹配的Y部的点来操作的。</p>
<h1 id="二、流程"><a href="#二、流程" class="headerlink" title="二、流程"></a>二、流程</h1><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>给X、Y两部点的顶标进行贪心地赋值，然后修改顶标值使得更多的边成为可行边，扩大相等子图，从而增加匹配，直到相等子图达到完备匹配。</p>
<h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>①初始化设定$lx[i]=max_{i \to j}(w[i][j])$,$ly[i]=0$</p>
<p>②对每个X部的点，<strong>尝试增加匹配</strong>。更新Y部点的松弛量，并求得顶标修改量。记录下最终贡献顶标修改量的<strong>Y部节点</strong>，即为本次增广的匹配点。为了降低复杂度，需要<strong>记录改善匹配的路径</strong>（用前向星）。所以调整完所有的松弛量和顶标修改后，更新匹配状态。</p>
<p>③答案就是Y部每个点与对应X部匹配点之间连边权值之和</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^3)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>注：这份代码适用于处理X、Y部节点数相等的情况</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,match[N],pre[N];</span><br><span class="line"><span class="keyword">bool</span> vis2[N];</span><br><span class="line">ll favor[N][N],val1[N],val2[N],slack[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x,y=<span class="number">0</span>,yy=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span> pre);</span><br><span class="line">	<span class="built_in">memset</span>(slack,INF,<span class="keyword">sizeof</span> slack);</span><br><span class="line">	match[<span class="number">0</span>]=p;  <span class="comment">// </span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ll d=INF;</span><br><span class="line">		x=match[y];</span><br><span class="line">		vis2[y]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis2[i])</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">if</span>(slack[i]&gt;val1[x]+val2[i]-favor[x][i]) &#123;</span><br><span class="line">				slack[i]=val1[x]+val2[i]-favor[x][i];</span><br><span class="line">				pre[i]=y;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(slack[i]&lt;d) &#123;</span><br><span class="line">				d=slack[i]; <span class="comment">//d取最小可能</span></span><br><span class="line">				yy=i; <span class="comment">//记录最小可能存在的点</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(vis2[i])</span><br><span class="line">				val1[match[i]]-=d,val2[i]+=d;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				slack[i]-=d;</span><br><span class="line">		&#125;</span><br><span class="line">		y=yy;</span><br><span class="line">	&#125; <span class="keyword">while</span>(match[y]);</span><br><span class="line">	<span class="keyword">while</span>(y) &#123;</span><br><span class="line">		match[y]=match[pre[y]]; <span class="comment">//bfs对访问路径进行记录，并在最后一并改变match</span></span><br><span class="line">		y=pre[y];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">	<span class="built_in">memset</span>(val1,<span class="number">0</span>,<span class="keyword">sizeof</span> val1);</span><br><span class="line">	<span class="built_in">memset</span>(val2,<span class="number">0</span>,<span class="keyword">sizeof</span> val2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis2,<span class="literal">false</span>,<span class="keyword">sizeof</span> vis2);</span><br><span class="line">		<span class="built_in">bfs</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		res+=favor[match[i]][i]; <span class="comment">//最后将对应匹配的边权求和输出</span></span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	ll w;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">			favor[i][j]=-INF;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%lld&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		favor[u][v]=<span class="built_in">max</span>(favor[u][v],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">KM</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,match[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="形象理解"><a href="#形象理解" class="headerlink" title="形象理解"></a>形象理解</h2><p>参考网上对于这一算法的形象理解</p>
<p>现在有N男N女，有些男生和女生之间互相有好感，我们将其好感程度定义为好感度，我们希望把他们两两配对，并且最后希望好感度和最大。</p>
<p><img src="C:/Users/LaiAng80586/Downloads/670878-20170604131038711-1791348557.png" alt="670878-20170604131038711-1791348557"></p>
<p>怎么选择最优的配对方法呢？</p>
<p>首先，每个女生会有一个期望值，就是与她有好感度的男生中最大的好感度。男生呢，期望值为0，就是……只要有一个妹子就可以啦，不挑~~</p>
<p>这样，我们把每个人的期望值标出来。</p>
<p><img src="https://images2015.cnblogs.com/blog/670878/201706/670878-20170604131636211-2003102082.png" alt="KM算法详解-wenr"></p>
<p>接下来，开始配对。</p>
<p>配对方法：</p>
<p>我们从第一个女生开始，分别为每一个女生找对象。</p>
<p>每次都从第一个男生开始，选择一个男生，使男女两人的<strong>期望和要等于两人之间的好感度</strong>。</p>
<p><strong>注意：每一轮匹配，每个男生只会被尝试匹配一次！</strong></p>
<h3 id="具体匹配过程"><a href="#具体匹配过程" class="headerlink" title="具体匹配过程"></a>具体匹配过程</h3><p><strong>为女1找对象</strong></p>
<p>（此时无人配对成功）</p>
<p>根据 “男女两人的期望和要等于两人之间的好感度”的规则</p>
<p>女1-男1：4+0 $\not=$ 3</p>
<p>女1-男3：4+0 $=$ 4</p>
<p>所以女1选择了男3</p>
<p><strong>女1找对象成功</strong></p>
<hr>
<p><strong>为女2找对象</strong></p>
<p>（此时女1—男3）</p>
<p>根据配对原则，女2选择男3</p>
<p>男3有主女1，女1尝试换人</p>
<p>我们尝试让女1去找别人</p>
<p>尝试失败</p>
<p>为女2找对象失败！</p>
<p><strong>为女2找对象失败</strong></p>
<hr>
<p>这一轮参与匹配的人有：女1，女2，男3。</p>
<p>怎么办？？？很容易想到的，这两个女生只能降低一下期望值了，降低多少呢？</p>
<p><strong>任意一个参与匹配女生能换到任意一个 <em>这轮</em> 没有被选择过的男生所需要降低的最小值</strong></p>
<p>比如：女1选择男1，期望值要降低1。 女2选择男1，期望值要降低1。 女2选择男2，期望值要降低2。</p>
<p>于是，只要期望值降低1，就有妹子可能选择其他人。所以<strong>妹子们的期望值要降低</strong>1点。</p>
<p>同时，刚才被抢的<strong>男生</strong>此时非常得意，因为有妹子来抢他，于是他的<strong>期望值提高</strong>了1点（就是同妹子们降低的期望值相同）。</p>
<p>于是期望值变成这样（当然，不参与刚才匹配过程的人期望值不变）</p>
<p><img src="https://images2015.cnblogs.com/blog/670878/201706/670878-20170604133607977-673472679.png" alt="KM详解-wenr"></p>
<p><strong>继续为女2找对象</strong></p>
<p>（此时女1—男3）</p>
<p>女2选择了男1</p>
<p>男1还没有被配对</p>
<p>女2找对象成功！</p>
<p><strong>为女2找对象成功</strong></p>
<hr>
<p><strong>为女3找对象</strong></p>
<p>（此时女1—男3，女2-男1）</p>
<p>女3没有可以配对的男生……</p>
<p>女3找对象失败</p>
<p><strong>为女3找对象失败</strong></p>
<hr>
<p>此轮只有女3参与匹配</p>
<p>此时应该为女3降低期望值</p>
<p>降低期望值1的时候，女3-男3可以配对，所以女3降低期望值1</p>
<p><img src="https://images2015.cnblogs.com/blog/670878/201706/670878-20170604134242836-1033770068.png" alt="KM算法详解"></p>
<p><strong>继续为女3找对象</strong></p>
<p>（此时女1—男3， 女2-男1）</p>
<p>女3相中了男3</p>
<p>此时男3已经有主女1，于是女1尝试换人</p>
<p>女1选择男1</p>
<p>而男1也已经有主女2，女2尝试换人</p>
<p>前面说过，每一轮匹配每个男生只被匹配一次</p>
<p>所以女2换人失败</p>
<p>女3找对象再次失败</p>
<p><strong>为女3找对象失败</strong></p>
<hr>
<p>这一轮匹配相关人员：女1，女2，女3，男1，男3</p>
<p>此时，只要女2降低1点期望值，就能换到男2</p>
<p>（前面提过 只要任意一个女生能换到任意一个没有被选择过的男生所需要降低的最小值）</p>
<p>我们把相应人员期望值改变一下</p>
<p><img src="https://images2015.cnblogs.com/blog/670878/201706/670878-20170604135204336-990535246.png" alt="KM算法详解-wenr"></p>
<p><strong>还是为女3找对象</strong></p>
<p>（此时女1—男3， 女2-男1）</p>
<p>女3选择了男3</p>
<p>男3有主女1，女1尝试换人</p>
<p>女1换到了男1</p>
<p>男1已经有主女2，女2尝试换人</p>
<p>女2换人男2</p>
<p>男2无主，匹配成功！！！</p>
<p><strong>为女3找对象成功</strong></p>
<hr>
<p>匹配成功！！！撒花~~</p>
<p>到此匹配全部结束</p>
<p>此时</p>
<p>女1-男1，女2-男2，女3-男3</p>
<p>好感度和为最大：9</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大权匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营3 C Minimum grid</title>
    <url>/2021/07/28/nowcoder3c/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有一个$n \times n$的方阵，其中一些格子可以填数，其他格子均不能填数，且每行有一个最大值要求$b_i$，每列有一个最大值要求$c_i$，即填的数得保证这些最大值要求被满足。现在求最小的填数之和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n\leq 2\cdot 10^3\\</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这种看起来具体需要“填一填”弄出具体方案的题目，不妨从<strong>必要条件</strong>入手去分析。我们猜测，在不填“多余的数”的情况下，这个和至少得是$\sum_{i=1}^n b_i+c_i$​​。很快我们发现这个必要条件可以优化，其实就是如果一个格子<strong>对应行列的最大值要求时相等</strong>的，那么其实填这个格子就<strong>节省</strong>了一个最大值。（如果不相等的话是不能实现“1换2”的）</p>
<p>所以我们的目标就是找出所有能够节省最大值的情况——<strong>同一行同一列</strong>只在上述的<strong>一个</strong>这种格子上放数，才能实现节省。于是我们用二分图求最大匹配来配置这些格子，即这种格子的行列连边，然后跑二分图匹配。再从答案中减掉匹配成功对应行列的最大值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> b[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">namespace</span> graph &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		node *nnext;</span><br><span class="line">	&#125; pool[<span class="number">2</span>*N],*h[<span class="number">2</span>*N];</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		node *p=&amp;pool[++cnt];</span><br><span class="line">		p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">		node *q=&amp;pool[++cnt];</span><br><span class="line">		q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> connect[N];</span><br><span class="line">	<span class="keyword">bool</span> state[N];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">			v=p-&gt;v;</span><br><span class="line">			<span class="keyword">if</span>(!state[v]) &#123;</span><br><span class="line">				state[v]=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(connect[v]==<span class="number">0</span> || <span class="built_in">dfs</span>(connect[v])) &#123;</span><br><span class="line">					connect[v]=u;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LL ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(state,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(state));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(j))</span><br><span class="line">				ret+=b[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">		ans+=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">		ans+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(b[u]==c[v])</span><br><span class="line">			graph::<span class="built_in">addedge</span>(u,n+v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans - graph::<span class="built_in">hungary</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>二分图最大匹配</tag>
        <tag>构图</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 D Rebuild Tree 与 Prufer序列知识点</title>
    <url>/2021/07/28/nowcoder4d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定一棵$n$个节点的树，现在删掉$k$条边再加上$k$条边再成为一棵树，问总方案数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
 1 \leq n \leq 5 \cdot 10^4\\
 k \leq min(n-1,100)</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这道题很好体现了两个基本问题——<strong>树的删边</strong>和<strong>树的计数</strong>。</p>
<p>对于树的删边问题，我们考虑删除$k$条边后形成的$k+1$​个连通块，记它们的大小为$s[1],s[2],…,s[k+1]$，为了计数方便，我们把这些连通块都抽象为一个点，那么这些点<strong>相互连接</strong>，需要枚举一个<strong>点度数</strong>，所以我们的方案数应该是</p>
<script type="math/tex; mode=display">
\sum_{\text{Tree of k+1 nodes}} \prod_{i=1}^{k+1} s_i^{d_{i}}</script><p>出现了点度数，我们不妨用Prufer序列的性质来化简这个式子（具体知识见下文），我们可以得到上式为：</p>
<script type="math/tex; mode=display">
\sum_{\forall s[1..k+1]} n^{k-1}\cdot\prod_{i=1}^{k+1}s_i</script><p>那么问题来了，其实$n^{k-1}$并不难算，关键是我们很难枚举所有的连通块大小为这个s序列的所有树的形态。于是我们谋求问题的转化：</p>
<p>上面这个式子把$n^{k-1}$​单提到外面后，剩下的$\sum$​等价于<em>我将原先这个树切了$k$​​​条边，剩下的连通块恰好选1个点的总方案数。**</em>恰好选一个点**这件事正是对于这个$\prod$</p>
<p>而这个问题就可以用树形DP来解决了。记$dp[x][y][0/1]$表示$x$的子树，一共删$y$条边，且$x$节点所在的连通块是否选中了点时的方案数。其状态转移可以在DFS时逐一添加子树来计算，具体转移见如下代码。</p>
<p>值得一提的是，根据出题人的讲评，这个DFS过程乍一看是$O(nk^2)$的，实际上是$O(nk)$的，因此可以通过。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line">LL dp[MAXN][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN];</span><br><span class="line">LL tmp[<span class="number">220</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//子树一条边不删的话形态是唯一的 </span></span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_dp</span>(v,u);</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));<span class="comment">//注意顺序 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;siz[u] &amp;&amp; i&lt;=k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;siz[v] &amp;&amp; i+j&lt;=k; j++) &#123;</span><br><span class="line">				<span class="comment">//Not delete.</span></span><br><span class="line">				tmp[i+j][<span class="number">0</span>]=(tmp[i+j][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">0</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j][<span class="number">1</span>]=(tmp[i+j][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">0</span>]%MOD</span><br><span class="line">				             +dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				<span class="keyword">if</span>(i+j==k)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//delete one more.  得符合定义，底下的儿子节点所在连通块相对独立，故必须选中 </span></span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(dp[u],tmp,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	n=<span class="built_in">mread</span>(),k=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		u=<span class="built_in">mread</span>(),v=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][k][<span class="number">1</span>]*<span class="built_in">quick_pow</span>(n,k<span class="number">-1</span>)%MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prufer序列"><a href="#Prufer序列" class="headerlink" title="Prufer序列"></a>Prufer序列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>对于一个$n$​​个节点的标号树，其Prufer序列是惟一的，长度为$n-2$。因此可以用于<strong>树的形态计数</strong>等问题。</p>
<p>其<strong>构造方法</strong>如下：</p>
<p>①选择当前树中编号最小的叶子，将其删除</p>
<p>②将刚才删除的叶子的父节点加入到序列中</p>
<p>③重复前两步，直到树为空</p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>根据Prufer序列的构造方法，不难看出以下的性质：</p>
<h4 id="一、一个点的度数-其在Prufer序列中出现次数-1"><a href="#一、一个点的度数-其在Prufer序列中出现次数-1" class="headerlink" title="一、一个点的度数 = 其在Prufer序列中出现次数 + 1"></a>一、一个点的度数 = 其在Prufer序列中出现次数 + 1</h4><h4 id="二、n个点的无根标号树形态总数为-n-n-2"><a href="#二、n个点的无根标号树形态总数为-n-n-2" class="headerlink" title="二、n个点的无根标号树形态总数为 $n^{n-2}$"></a>二、n个点的无根标号树形态总数为 $n^{n-2}$</h4><p>这一条原因是我们可以枚举Prufer序列，而每一个位置可以在$[1…n]$中任取</p>
<h4 id="三、n个点的有根标号树形态总数为-n-n-1"><a href="#三、n个点的有根标号树形态总数为-n-n-1" class="headerlink" title="三、n个点的有根标号树形态总数为$n^{n-1}$"></a>三、n个点的有根标号树形态总数为$n^{n-1}$</h4><p>其实就是第二条再枚举根节点。</p>
<h4 id="四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i"><a href="#四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i" class="headerlink" title="四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$"></a>四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$</h4><script type="math/tex; mode=display">
\frac{(n-2)!}{\prod_{i=1}^{n}(d_i-1)!}</script><h6 id="这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"><a href="#这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。" class="headerlink" title="这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"></a>这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。</h6>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu AI相关软件安装心得</title>
    <url>/2021/07/30/pythonDL/</url>
    <content><![CDATA[<p>在Ubuntu上安装<code>tensorflow</code>的过程真是一波三折，挺折腾人的。期间也查阅了不少CSDN的博客。不过也算是增进了对Ubuntu系统的了解和终端的使用吧。</p>
<p>好不容易入手了配有较高水平GPU的笔记本，当然要安装<code>tensorflow-gpu</code>版本了！不过经过摸索（呜呜呜），这个<code>gpu</code>版本的安装并不简简单单是一行pip就能解决的问题。依次要安装好<code>nvidia</code>显卡，<code>CUDA</code>和<code>cuDNN</code>,当然还有<code>Anaconda</code>等。由于之前出于省事安装了个<code>LambdaStack</code>，现在这些个软件包其实是混乱的，就可能许多软件包已经下载到电脑里了，只不过没有启用或者依赖关系没有解决云云。</p>
<p>具体的命令行就不写了，网上大多能查到。就记一记在自己电脑上试的坑。</p>
<h2 id="NVIDIA显卡的安装"><a href="#NVIDIA显卡的安装" class="headerlink" title="NVIDIA显卡的安装"></a>NVIDIA显卡的安装</h2><p>1、要禁用、卸载Ubuntu自带的nouveau驱动</p>
<p>2、卸载曾经安装残存的<code>nvidia</code>驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove nvidia-*</span><br></pre></td></tr></table></figure>
<p>3、安装NVIDIA驱动时必须要关闭图形界面<code>Ctrl+Alt+F1</code>进入<code>tty</code>虚拟命令行，把命令先写下来，因为一时上不了网。</p>
<p>大概有这么几条</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service lightdm stop  //关闭图形界面</span><br><span class="line">sudo chmod a+x ...</span><br><span class="line">sudo ./... (此处为驱动) -no-x-check -no-nouveau-check -no-opengl-files</span><br></pre></td></tr></table></figure>
<p>然后一通安装，期间有设置安全启动密码什么的，最好记住。然后重启</p>
<p>检查是否安装成功，执行<code>nvidia-smi</code>如果能够看到一张大表格就行了</p>
<p>还有一条<code>modprobe nvidia</code>似乎是启用</p>
<p>4、此外必要时需要在BIOS中设置关闭安全启动。</p>
<h2 id="CUDA的安装"><a href="#CUDA的安装" class="headerlink" title="CUDA的安装"></a>CUDA的安装</h2><p>最麻烦的就是出现诸如“下列软件包有未满足的依赖关系： cuda : 依赖: cuda-11-4 (&gt;= 11.4.xxx) 但是它将不会被安装”的报错。针对这个报错从网上弄了好几种设置，也不知道到底哪个是真正奏效的（汗）</p>
<ul>
<li><code>gcc/g++</code>的降级（这个还是很重要的，主要用到<code>update-alternatives</code>命令）</li>
<li>开启Ubuntu软件更新（重要位置和推荐）</li>
<li>用aptitude代替apt-get（但我后来没用deb安装包似乎这一条没什么用了）</li>
</ul>
<p>虽然我的机子是Ubuntu20.04，但最后下载的是CUDA11.4版本且适用于Ubuntu18.04<code>run</code>文件安装成功过的。</p>
<h2 id="cuDNN的安装"><a href="#cuDNN的安装" class="headerlink" title="cuDNN的安装"></a>cuDNN的安装</h2><p>这个就相对好弄多了。</p>
<p>只要先装<code>Runtime Library</code>再装<code>Developer Library</code>和<code>Sample</code>三个安装包即可。</p>
<p>验证成功安装时，将<code>mnistCUDNN</code>的实例拷到个人目录下，然后还得更新一波FreeImage，以及在make的时候sudo一下，Test Passed.</p>
<h2 id="TensorFlow-GPU的安装"><a href="#TensorFlow-GPU的安装" class="headerlink" title="TensorFlow-GPU的安装"></a>TensorFlow-GPU的安装</h2><p>还是用conda来做比较方便。首先换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span><br><span class="line">python oh-my-tuna.py</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.8</span><br><span class="line">pip install -U pip</span><br><span class="line">conda activate tf</span><br><span class="line">pip install -U tensorflow-gpu</span><br></pre></td></tr></table></figure>
<p>差不多就可以了。</p>
<p>最后验证一下即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 G Product</title>
    <url>/2021/07/27/nowcoder4g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定三个整数$n,k,D$,设数列$a_i,i=1,2,…,n$,求对于所有数列满足$\forall i \in [1,n],a_i \geq 0$​且$\sum_{i=1}^na_i=D$​的情况下，</p>
<script type="math/tex; mode=display">
\frac{D!}{\prod_{i=1}^n(a_i+k)!}</script><p>的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 50\\
0\leq k \leq 50\\
D \leq 10^8</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>此题比较神仙。首先分母上$(a_i+k)!$​不太好看，假设一个$a_i :=a_i+k$​.我们考虑一个<strong>组合模型</strong>，一个长度为D的数列，每个位置上可以填$[1,n]$中的任何正整数，一共有多少中填法。通过算两次，假设我们枚举$i$出现的次数为$a_i$​，或者直接乘法原理，那么这个组合模型的描述为</p>
<script type="math/tex; mode=display">
(\sum_{a_i\geq0}=D) \prod_{i=1}^n \frac{D!}{a_i!}=n^D</script><p>那么回到本题。如果不要求$a_i \geq 0$即$a_i+k \geq k$时，则答案就是$n^{D+nk}$</p>
<p>现在问题就是必须要求$a_i+k\geq k$。因此我们用容斥原理做。</p>
<p>由于$n,k$都比较小，所以不妨记$dp[i][j]$表示“有$i$个数不满足要求且这$i$个数的和是$j$”，对于剩下的$n-i$​个数可以满足要求也可以不满足要求，其和也是确定的$D+nk-j$.因此我们可以求出”至少有$i$​个数不满足要求时对答案的贡献”:</p>
<script type="math/tex; mode=display">
C_{n}^{i} \cdot \sum_j dp[i][j]\cdot(n-i)^{D+nk-j}</script><p>因此答案就是$n^{D+nk}$减去”至少一个违反条件的”加上“至少两个违反条件的”减去“至少三个违反条件的”…如此递推即可。</p>
<p>最后再乘上$\frac{D!}{(D+nk)!}$满足题意。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 H题</title>
    <url>/2021/07/27/test/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>考虑$x=\prod_{i}p_i^{a_i}$,$y=\prod_{i}p_i^{b_i}$.定义$x \bigotimes y$=$\prod_{i}p_i^{|a_i-b_i|}$,现在给定一个数列$a[1…n]$，求出</p>
<script type="math/tex; mode=display">
b[i]=\sum_{1 \leq j,k \leq n,j \bigotimes k=i}a_jk^c</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先通过$|a_i-b_i|=max(a_i,b_i)-min(a_i,b_i)$来理解这个定义本质是$\frac{lcm(a,b)}{gcd(a,b)}$,故进一步得到</p>
<script type="math/tex; mode=display">
i=\frac{j}{gcd} \cdot \frac{k}{gcd}</script><p>那么不妨令</p>
<script type="math/tex; mode=display">
s=\frac{j}{gcd},t=\frac{k}{gcd}</script><p>故</p>
<script type="math/tex; mode=display">
i=s \cdot t \\(s,t)=1</script><p>因此</p>
<script type="math/tex; mode=display">
b[i]=\sum_s (\frac{i}{s})^c \sum_{gcd} (a_{s \cdot gcd})\cdot gcd^c</script><p>由此可见后面这个$gcd$的部分可以通过对于一个数枚举其倍数预处理得到，其复杂度为</p>
<script type="math/tex; mode=display">
n \cdot \sum_{i=1}^N \frac{1}{i} =nlogn</script><p>前面这个$s$的枚举是$O(n\sqrt n)$,但并不满。因此总复杂度是可以接受的。</p>
<p>此外，对于$s,t$并没有大小之分，但是需要保证$s \cdot gcd ,t \cdot gcd \leq n$,因此需要在上述计算中选择较小的$gcd$上限来运算。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>本题在考场上低级错误在于快速幂。</p>
<p>枚举因子时<code>sqrt</code>应当提前算出！</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">    LL ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL b[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line">vector&lt;LL&gt; rela[MAXN];</span><br><span class="line">LL my_pow[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;H.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    LL now;</span><br><span class="line">    <span class="keyword">int</span> s,t,qrt;</span><br><span class="line">    n=<span class="built_in">mread</span>(),c=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)my_pow[i]=<span class="built_in">quick_pow</span>(i,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,k=<span class="number">1</span>; j&lt;=n; j+=i,k++) &#123; <span class="comment">//gcd enum</span></span><br><span class="line">            now=(now+<span class="number">1ll</span>*a[j]*my_pow[k]%MOD+MOD)%MOD;</span><br><span class="line">            rela[i].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        qrt=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=qrt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            s=j,t=i/j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gcd</span>(s,t)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s!=t) &#123;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[t]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[t][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span>  b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sum=sum^b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
