<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome to LaiAng80586&#39;s Blog！(&gt;ω&lt;*)</title>
    <url>/2021/07/27/about/</url>
    <content><![CDATA[<h2 id="Self-Introduction"><a href="#Self-Introduction" class="headerlink" title="Self Introduction"></a>Self Introduction</h2><p>LaiAng80586</p>
<p>BUAA SCSE 2020</p>
]]></content>
  </entry>
  <entry>
    <title>2016-2017 ACM-ICPC Pacific Northwest Regional Contest (Div. 1) Buggy Robot</title>
    <url>/2021/07/30/gym101201B/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有个机器人在一个网格中靠执行一串<code>LRUD</code>指令行动，但这串指令有问题，并不能保证机器人一定能从起点走到终点。当机器人执行一条指令可能出界或遇到障碍，则相当于这条指令无效。而一旦机器人到达了终点，则之后未执行的指令都不用执行。现在问在原串上最少增添多少条指令，可以使机器人从起点到达终点。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n,m,k \leq 50</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>看到字符串就想匹配，有些狭隘了。确实有匹配的因素，但我们关心的是<strong>从一个字符到下一个字符的转移</strong>，而并非事先构造出整个串。其实我们<strong>并不关心具体增添那些</strong>指令，只关心最小增添的<strong>个数</strong>。而增添的情形，实际上是由坐标来决定的。</p>
<p>因此我们记$dp[i][j][k]$表示当前机器人位于$(i,j)$，即将执行第$k$​条指令时，​达到此状态最小的增添指令次数。那么其实还是枚举四个方向的情形，如果恰好枚举的方向和指令方向一致的话，就去更新$(i’,j’,k+1)$状态的dp值，否则相当于到了下一个点还是执行第$k$条指令。</p>
<p>复杂度为$O(nmk)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">char</span> mp[<span class="number">55</span>][<span class="number">55</span>],cmd[<span class="number">55</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">55</span>][<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,ans,len;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y,k;</span><br><span class="line">&#125;;</span><br><span class="line">queue&lt;node&gt; Q;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>((x&gt;=<span class="number">1</span>) &amp;&amp; (x&lt;=n) &amp;&amp; (y&gt;=<span class="number">1</span>) &amp;&amp; (y&lt;=m) &amp;&amp; mp[x][y]!=<span class="string">&#x27;#&#x27;</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;L&#x27;</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;R&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;U&#x27;</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span>(c==<span class="string">&#x27;D&#x27;</span>)<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> dx[<span class="number">4</span>]= &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> dy[<span class="number">4</span>]= &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//rows &amp; cols</span></span><br><span class="line">	node now,nxt;</span><br><span class="line">	<span class="keyword">int</span> cmd_go;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=m; j++)</span><br><span class="line">			<span class="keyword">if</span>(mp[i][j]==<span class="string">&#x27;R&#x27;</span>) &#123;</span><br><span class="line">				Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">					i,j,<span class="number">1</span></span><br><span class="line">				&#125;);</span><br><span class="line">				dp[i][j][<span class="number">1</span>]=<span class="number">0</span>;  <span class="comment">//字符串标号 </span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="keyword">while</span>(!Q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">		now=Q.<span class="built_in">front</span>();</span><br><span class="line">		Q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//		printf(&quot;%d %d %d val=%d\n&quot;,now.x,now.y,now.k-1,dp[now.x][now.y][now.k]); </span></span><br><span class="line"><span class="comment">//		system(&quot;PAUSE&quot;);</span></span><br><span class="line">		<span class="keyword">if</span>(mp[now.x][now.y]==<span class="string">&#x27;E&#x27;</span>) &#123;</span><br><span class="line">			ans=<span class="built_in">min</span>(ans,dp[now.x][now.y][now.k]);  <span class="comment">//可以不执行完既定的指令</span></span><br><span class="line">			<span class="keyword">continue</span>; <span class="comment">//!</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++) &#123;</span><br><span class="line">			nxt.x=now.x+dx[i];</span><br><span class="line">			nxt.y=now.y+dy[i];</span><br><span class="line">			<span class="keyword">if</span>(now.k&lt;=len)</span><br><span class="line">				cmd_go=<span class="built_in">num</span>(cmd[now.k]);</span><br><span class="line">			<span class="keyword">else</span> cmd_go=<span class="number">-1</span>;</span><br><span class="line">			<span class="keyword">if</span>(!<span class="built_in">check</span>(nxt.x,nxt.y)) &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line">					<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//This is an invalid direct.</span></span><br><span class="line">						<span class="keyword">if</span>(dp[now.x][now.y][now.k+<span class="number">1</span>]==INF)</span><br><span class="line">							Q.<span class="built_in">push</span>(&#123;</span><br><span class="line">							now.x,now.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[now.x][now.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(cmd_go==i) &#123;</span><br><span class="line"><span class="comment">//					printf(&quot;??\n&quot;);</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] &gt; dp[now.x][now.y][now.k]) &#123; <span class="comment">//No need to add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k+<span class="number">1</span>] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k+<span class="number">1</span></span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k+<span class="number">1</span>]=dp[now.x][now.y][now.k];</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;<span class="comment">//Guaranteed that len will not be exceeded.</span></span><br><span class="line">					<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] &gt; dp[now.x][now.y][now.k] + <span class="number">1</span>) &#123; <span class="comment">//add new</span></span><br><span class="line">						<span class="keyword">if</span>(dp[nxt.x][nxt.y][now.k] == INF)</span><br><span class="line">							Q.<span class="built_in">push</span>( &#123;</span><br><span class="line">							nxt.x,nxt.y,now.k</span><br><span class="line">						&#125;);</span><br><span class="line">						dp[nxt.x][nxt.y][now.k]=dp[now.x][now.y][now.k] + <span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;B.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//	freopen(&quot;B-1.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,mp[i]+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,cmd+<span class="number">1</span>);</span><br><span class="line">	len=<span class="built_in">strlen</span>(cmd+<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">memset</span>(dp,<span class="number">63</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"><span class="comment">//	printf(&quot;%d\n&quot;,0x3f3f3f3f);</span></span><br><span class="line">	ans=INF;</span><br><span class="line"><span class="comment">//	printf(&quot;%d %d\n&quot;,dp[0][0][0],ans);</span></span><br><span class="line">	<span class="built_in">BFS</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论 递推与动归</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 B</title>
    <url>/2021/07/27/2021Nowcoder4A/</url>
    <content><![CDATA[<h2 id="A-Course"><a href="#A-Course" class="headerlink" title="A Course"></a>A Course</h2><p><strong>生成函数</strong>来计数不同课的选择方案</p>
<script type="math/tex; mode=display">
\sum_{i=0}^n x^i = \frac{1}{1-x^n}\\
f_i(x) =\prod_{i \to j}  f_j...</script><h2 id="B-Sample-Game"><a href="#B-Sample-Game" class="headerlink" title="B Sample Game"></a>B Sample Game</h2><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>有一个随机数生成器可以生成$[1,n]$中所有数，每个数被生成的概率为$p_i$,该生成器如果生成的数均不小于之前生成的所有数，则继续生成，否则停止。记每一轮一共生成了$x$个数，则收益为$x^2$。问期望收益。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><script type="math/tex; mode=display">
1 \leq n \leq 100</script><h3 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h3><p>这个题巧妙之处在于对长度发生概率的<strong>设而不求</strong>。</p>
<p>首先我们根据题意知道除了最后一个数之外，该生成序列是单调不降的。那么一旦我们知道了每一个数被生成了多少次，则生成序列唯一确定。因此我们可以用<strong>生成函数</strong>来描述这个期望。</p>
<p>注意到对于一种数，它的被生成的无限期望为</p>
<script type="math/tex; mode=display">
E(\infty)=\sum_{i=1}^{\infty}p_s^i \cdot x_s^i=\frac{1}{1-p_sx_s}</script><p>因此从<strong>序列长度</strong>为1到长度为无穷的期望组合的描述如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x)&=\sum_{i=1}^{\infty} \big(\sum_{s_1+s_2+...+s_n=i} \prod_{k=1}^n p_k^{s_k}) \cdot x^i\\
&=\sum_{i=1}^{\infty}P(len>i)x^i\\
&=\prod_{i=1}^n (1+p_ix_i+p_i^2x_i^2+...+p_i^{\infty}x_i^{\infty})\\
&=\prod_{i=1}^n \frac{1}{1-p_ix}
\end{aligned}</script><p>但这个描述的目的只是间接的得到概率的关系，我们还是得考虑具体的期望公式，再设法往上面得到的这个$f(x)$上转化。</p>
<script type="math/tex; mode=display">
\begin{aligned}
E&=\sum_{i=0}^{\infty}\big(P(len>i) -P(len>i+1))\cdot i^2\\
&展开后按照P(len>i)合并项得到\\
&=\sum_{i=0}^{\infty}P(len>i)[(i+1)^2-i^2]\\
&=\sum_{i=0}^{\infty}P(len>i)(2i+1)\\
&=2\cdot f'(1)+f(1)
\end{aligned}</script><p>下面再考虑求$f’(x)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
令g_i(x)&=\frac{1}{1-p_ix}\\
则g_i'(x)&=\frac{p_i}{(1-p_ix)^2}\\
故f'(x)&=\sum_{i=1}^{n}g_i'(x)\cdot \prod_{j \not=i}g_j(x)\\
&=f(x)\cdot \sum_{i=1}^n \frac{p_i}{1-p_ix}
\end{aligned}</script><p>故答案就是</p>
<script type="math/tex; mode=display">
\big(1+2\cdot\sum_{i=1}^n \frac{p_i}{1-p_i})f(1)</script>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
        <tag>概率</tag>
        <tag>设而不求</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 D Rebuild Tree 与 Prufer序列知识点</title>
    <url>/2021/07/28/nowcoder4d/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定一棵$n$个节点的树，现在删掉$k$条边再加上$k$条边再成为一棵树，问总方案数。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
 1 \leq n \leq 5 \cdot 10^4\\
 k \leq min(n-1,100)</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这道题很好体现了两个基本问题——<strong>树的删边</strong>和<strong>树的计数</strong>。</p>
<p>对于树的删边问题，我们考虑删除$k$条边后形成的$k+1$​个连通块，记它们的大小为$s[1],s[2],…,s[k+1]$，为了计数方便，我们把这些连通块都抽象为一个点，那么这些点<strong>相互连接</strong>，需要枚举一个<strong>点度数</strong>，所以我们的方案数应该是</p>
<script type="math/tex; mode=display">
\sum_{\text{Tree of k+1 nodes}} \prod_{i=1}^{k+1} s_i^{d_{i}}</script><p>出现了点度数，我们不妨用Prufer序列的性质来化简这个式子（具体知识见下文），我们可以得到上式为：</p>
<script type="math/tex; mode=display">
\sum_{\forall s[1..k+1]} n^{k-1}\cdot\prod_{i=1}^{k+1}s_i</script><p>那么问题来了，其实$n^{k-1}$并不难算，关键是我们很难枚举所有的连通块大小为这个s序列的所有树的形态。于是我们谋求问题的转化：</p>
<p>上面这个式子把$n^{k-1}$​单提到外面后，剩下的$\sum$​等价于<em>我将原先这个树切了$k$​​​条边，剩下的连通块恰好选1个点的总方案数。**</em>恰好选一个点**这件事正是对于这个$\prod$</p>
<p>而这个问题就可以用树形DP来解决了。记$dp[x][y][0/1]$表示$x$的子树，一共删$y$条边，且$x$节点所在的连通块是否选中了点时的方案数。其状态转移可以在DFS时逐一添加子树来计算，具体转移见如下代码。</p>
<p>值得一提的是，根据出题人的讲评，这个DFS过程乍一看是$O(nk^2)$的，实际上是$O(nk)$的，因此可以通过。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		c=<span class="built_in">getchar</span>();</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">	<span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	node *nnext;</span><br><span class="line">&#125; pool[MAXN&lt;&lt;<span class="number">1</span>],*h[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	node *p=&amp;pool[++cnt];</span><br><span class="line">	p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">	node *q=&amp;pool[++cnt];</span><br><span class="line">	q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line">LL dp[MAXN][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">	LL ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b &amp; <span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">		a=a*a%MOD;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN];</span><br><span class="line">LL tmp[<span class="number">220</span>][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_dp</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	siz[u]=<span class="number">1</span>;</span><br><span class="line">	dp[u][<span class="number">0</span>][<span class="number">1</span>]=dp[u][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  <span class="comment">//子树一条边不删的话形态是唯一的 </span></span><br><span class="line">	<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">		v=p-&gt;v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">get_dp</span>(v,u);</span><br><span class="line">		<span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));<span class="comment">//注意顺序 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;siz[u] &amp;&amp; i&lt;=k; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;siz[v] &amp;&amp; i+j&lt;=k; j++) &#123;</span><br><span class="line">				<span class="comment">//Not delete.</span></span><br><span class="line">				tmp[i+j][<span class="number">0</span>]=(tmp[i+j][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">0</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j][<span class="number">1</span>]=(tmp[i+j][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">0</span>]%MOD</span><br><span class="line">				             +dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				<span class="keyword">if</span>(i+j==k)<span class="keyword">continue</span>;</span><br><span class="line">				<span class="comment">//delete one more.  得符合定义，底下的儿子节点所在连通块相对独立，故必须选中 </span></span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">0</span>]+dp[u][i][<span class="number">0</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD;</span><br><span class="line">				tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]=(tmp[i+j+<span class="number">1</span>][<span class="number">1</span>]+dp[u][i][<span class="number">1</span>]*dp[v][j][<span class="number">1</span>]%MOD+MOD)%MOD; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(dp[u],tmp,<span class="built_in"><span class="keyword">sizeof</span></span>(tmp));</span><br><span class="line">		siz[u]+=siz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	n=<span class="built_in">mread</span>(),k=<span class="built_in">mread</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">		u=<span class="built_in">mread</span>(),v=<span class="built_in">mread</span>();</span><br><span class="line">		<span class="built_in">addedge</span>(u,v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">get_dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,dp[<span class="number">1</span>][k][<span class="number">1</span>]*<span class="built_in">quick_pow</span>(n,k<span class="number">-1</span>)%MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Prufer序列"><a href="#Prufer序列" class="headerlink" title="Prufer序列"></a>Prufer序列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>对于一个$n$​​个节点的标号树，其Prufer序列是惟一的，长度为$n-2$。因此可以用于<strong>树的形态计数</strong>等问题。</p>
<p>其<strong>构造方法</strong>如下：</p>
<p>①选择当前树中编号最小的叶子，将其删除</p>
<p>②将刚才删除的叶子的父节点加入到序列中</p>
<p>③重复前两步，直到树为空</p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><p>根据Prufer序列的构造方法，不难看出以下的性质：</p>
<h4 id="一、一个点的度数-其在Prufer序列中出现次数-1"><a href="#一、一个点的度数-其在Prufer序列中出现次数-1" class="headerlink" title="一、一个点的度数 = 其在Prufer序列中出现次数 + 1"></a>一、一个点的度数 = 其在Prufer序列中出现次数 + 1</h4><h4 id="二、n个点的无根标号树形态总数为-n-n-2"><a href="#二、n个点的无根标号树形态总数为-n-n-2" class="headerlink" title="二、n个点的无根标号树形态总数为 $n^{n-2}$"></a>二、n个点的无根标号树形态总数为 $n^{n-2}$</h4><p>这一条原因是我们可以枚举Prufer序列，而每一个位置可以在$[1…n]$中任取</p>
<h4 id="三、n个点的有根标号树形态总数为-n-n-1"><a href="#三、n个点的有根标号树形态总数为-n-n-1" class="headerlink" title="三、n个点的有根标号树形态总数为$n^{n-1}$"></a>三、n个点的有根标号树形态总数为$n^{n-1}$</h4><p>其实就是第二条再枚举根节点。</p>
<h4 id="四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i"><a href="#四、n个点的无根标号树形态总数，要求第-i-个点的度数为-d-i" class="headerlink" title="四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$"></a>四、n个点的无根标号树形态总数，要求第$i$个点的度数为$d_i$</h4><script type="math/tex; mode=display">
\frac{(n-2)!}{\prod_{i=1}^{n}(d_i-1)!}</script><h6 id="这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"><a href="#这个排列组合相当于我假设-i-对应的-d-i-个标号都是不同的，所以一共有-n-2-种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。" class="headerlink" title="这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。"></a>这个排列组合相当于我假设$i$对应的$d_i$个标号都是不同的，所以一共有$(n-2)!$种排法，然后再”内部去重”，把内部的排列消除掉，所以就有了分母的连乘式。</h6>]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>树形DP</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年7月训练</title>
    <url>/2021/07/27/2021%E5%B9%B47%E6%9C%88%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<h1 id="202107月训练"><a href="#202107月训练" class="headerlink" title="202107月训练"></a>202107月训练</h1><h3 id="CF-1547F"><a href="#CF-1547F" class="headerlink" title="CF 1547F"></a>CF 1547F</h3><p>其实我们已经想到了本质是求<strong>最长的一段不是全局公约数的子序列</strong>长度，而且$O(\sum n)$的提示也容易使人明白需要用类似尺取的方法。但差点意思的是怎么尺取呢？</p>
<p>之前失败的思路，问题在于要考虑的质因数太多，并不能动态维护当前段的所有质因数。所以这时候我们需要估计对于每一个数，其<strong>质因数个数的上限</strong>——其实就是8个，所以一个一个考虑是足够的。那么问题需要转化，也就是首先所有的数都除掉全局公约数，这样就是求最长的一段$gcd&gt;1$的子序列。</p>
<p>那么我们按照线性筛得到的筛法树的边权<strong>（注意严格保存最小质因子）</strong>，容易得到每个数的因数分解，那么对于每一个数$a_i$,枚举它的所有质因数$p$，然后向左向右扩展，每扩展一个数，就把它的$p$从其质因数集合中消去，这样就可以不断更新最大长度。</p>
<p><strong>算法标签</strong> <code>数论</code> <code>线性筛</code> <code>双指针/尺取法</code></p>
<h3 id="CF-1547G"><a href="#CF-1547G" class="headerlink" title="CF 1547G"></a>CF 1547G</h3><p>基本思路是正确的，就是要用SCC来统一处理环。然后1是唯一确定的源点，这个条件很好，使得DFS和Tarjan过程仅从1开始就行。然后从1开始到某点的访问次数，由于只考虑2次以上有限次，所以DFS就可以统计，并不需要DP。最后凡是从1到某个点路径经过SCC（或者自环）的，$ans_i=-1$</p>
<p><code>算法标签</code> <code>图论</code> <code>强连通分量</code></p>
<h3 id="CF-1391D"><a href="#CF-1391D" class="headerlink" title="CF 1391D"></a>CF 1391D</h3><p>这个题其实还是一个奇偶的构造。</p>
<p>首先行数超过4行和行数只有1行的情况很容易处理。那么先考虑两行的情况。这时的偶方阵就是$2 \times 2$的方阵，所以如果有奇数个1，相邻$2\times1$的列的1个数奇偶性应该不同。所以整个矩阵最终效果，就是“奇偶奇偶”的情形，或者”偶奇偶奇”的情形。按照这两种情况扫一遍即可。</p>
<p>那么行数为3的情况怎么样呢？其实这里就是化归，前两行和后两行分别实现$n=2$时奇偶分布，所以是四种情况，同样扫就行。</p>
<p><strong>算法标签</strong> <code>奇偶分析</code></p>
<h3 id="CF-1550D"><a href="#CF-1550D" class="headerlink" title="CF 1550D"></a>CF 1550D</h3><p>这题核心在于一个偏移量的思想。设置$a_i=i+k_i$然后分析$k_i$的性质，来计数。具体思路见题解。</p>
<p><img src="https://tva1.sinaimg.cn/large/0066rFaply8gsvgpc69s5j30wb0ldjyg.jpg" alt="image-20210718152335714"></p>
<h3 id="CF-1550F"><a href="#CF-1550F" class="headerlink" title="CF 1550F"></a>CF 1550F</h3><p>这个题目很综合，也体现<strong>建图和图的处理的</strong>一些技巧。</p>
<p>首先怎么考虑每一次$[d-k,d+k]$这个范围的跳跃的构建。其实最<strong>朴素的想法</strong>是枚举两个节点，连接一条边，边权就是坐标差的绝对值。那么适配这个题目，就再把$d$考虑进去，变成$w=|d-|a_u-a_v||$。所以如果从$s$到$i$经过的若干边，他的边权$w$都不超过$k$，那么就是满足要求的。</p>
<p>考虑到每一次的$k$是变动的，$k$越大，相当于跳跃的约束越小。因此我们就考虑尽可能用$w$的边来构成从$s$到$i$的路径，这样就可以更大化地满足要求苛刻的$k$。于是我们可以考虑<strong>求一棵最小生成树</strong>。</p>
<p>但是个$n^2$量级的完全图，因此普通的Kruskal和Prim是不行的。我们用一个新算法——$Boruvka$。</p>
<p>Boruvka 算法的一句话思想便是：</p>
<p>“从<em>所有当前的连通块向其他连通块<strong>扩展出最小边</strong></em>，直到只剩一个连通块”，其中取最小边的贪心思想是 Kruskal 的主体，而向外扩展又是 Prim 的思想 —— 基于另外两种生成树算法，Boruvka 的正确性显然。</p>
<p>其代码框架如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> 连通块个数&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        mn[i] = 连接 i 与其他连通块的最小边</span><br><span class="line">    <span class="keyword">for</span> 每个连通块 i</span><br><span class="line">        <span class="keyword">if</span> mn[i] 连接两个不同的连通块</span><br><span class="line">            ans += mn[i]</span><br><span class="line">            <span class="built_in">Merge</span>( mn[i] 连接的连通块 )</span><br><span class="line">            连通块个数 --</span><br></pre></td></tr></table></figure>
<p>而不同的题目难点就在于快速计算$mn_i$。对于这道题而言，其实$mn_i$就是要找到可以向其他连通块扩展的权值在$[a_i-d,a_i+d]$范围内的最小边。<strong>那么我们可以利用<code>set</code>+<code>lower_bound</code>来求这个最小边</strong>。</p>
<p>所以求得最小边后，就用vector维护的并查集来合并（小并入大）维护连通块，同时在新图上连接无向边。</p>
<p>运行完Boruvka算法后，再从$s$出发DFS遍历整个MST，求得它到其他点路径上的权值最大值。最后处理询问时只需要考虑这个权值最大值是不是比k来的小就行了。</p>
<p>复杂度$O(nlog^2n)$</p>
<p>算法标签 <code>最小生成树</code> <code>启发式合并</code> <code>图论建图</code></p>
<h3 id="CF-1550E"><a href="#CF-1550E" class="headerlink" title="CF 1550E"></a>CF 1550E</h3><p>这道题核心在于<strong>模拟匹配</strong>。</p>
<p>从<a href="https://frozenguardian.blog.csdn.net/">Frozen_Guardian</a>的博客上学到了关于这种<strong>状压</strong>的一些真知灼见。</p>
<blockquote>
<p>状压$dp$就是全排列问题的一种优化，所以状压$dp$可以解决的问题，全排列暴力枚举肯定也是可以解决的。所以先将问题简化，假设本题放开全排列该如何去做？</p>
</blockquote>
<p>我们要全排列什么？其实相当于<strong>从左到右依次放置待判定长度的相同字母子串</strong>。所以问题的关键就在于判别不同排列时能不能恰好匹配？所以这里就借助了序列自动机的概念。我们记$nnext[i][j]$表示从字符串第$i$个字符开始，其<strong>最早</strong>完全匹配第$j$种字符的待判定长度的字串时，下一个位置是多少？那么计算就是从后往前计算，如果借助？和已有的字母能够新增出一个完全的匹配，那么就赋值，否则照搬$nnext[i+1][j]$。</p>
<p>再考虑$dp$的转移，很容易想到$dp[mask]$就是已经使用字母的状态，这个dp值的含义是完成状态内这些字母的匹配后，<strong>最小的下一个位置</strong>（相当于一个$end$指针）。所以说我们其实并不关心从左到右到底是如何安排的，只需要按照$nnext$来辅助转移就可以了。</p>
<p>所以最后的判定标准就是如果$dp[2^k-1]$在$n-1$范围内，就是可以的。主函数二分答案即可。</p>
<p><strong>算法标签</strong> <code>二分答案</code> <code>序列自动机</code> <code>状压DP</code></p>
<h2 id="Nowcoder-Summer-2"><a href="#Nowcoder-Summer-2" class="headerlink" title="Nowcoder Summer 2"></a>Nowcoder Summer 2</h2><h3 id="J-Product-of-GCDs"><a href="#J-Product-of-GCDs" class="headerlink" title="J Product of GCDs"></a>J Product of GCDs</h3><p>给定一个集合，求其所有大小为$k$的子集的$gcd$之积</p>
<p>基本思路在赛场上就讨论的很清楚了，事后看题解也大致是这个思路。但赛场上没写出来的原因，是欧拉函数不会求。</p>
<p>把所有的数按照<strong>所含的质因子分类</strong>，朴素来说就是每一个质数开一个桶，把凡是含有这个质因子的数往这个桶里装，然后这个桶不断的处理该质因子的若干次幂的情况，相当于每一次把桶里所有数除一遍这个质数，然后删掉不再含有该质因子的数，每一次操作后对桶的大小做一个组合数的快速幂：</p>
<script type="math/tex; mode=display">
ans \gets prime^{C_{size}^k}</script><p>这个组合数数值很大，难以存储，又考虑这个组合数在指数的位置上，所以先求出$\varphi(p)$,然后用公式$C_n^k=C_{n-1}^{k}+C_{n-1}^{k-1}$来递推取模得到所需的组合数，对一组数据复杂度为$O(nk)$</p>
<p>此外关于实现，其实朴素想法中的“桶”是不需要用<code>STL​</code>的什么容器来实现的。只需要每次枚举质数和质数的幂次即可。因为用了容器，反而会多出来一些复杂度。</p>
<p><strong>算法标签</strong> <code>欧拉函数</code> <code>组合数</code> </p>
<h3 id="G-League-of-Legends"><a href="#G-League-of-Legends" class="headerlink" title="G League of Legends"></a>G League of Legends</h3><p>将$n$条线段分成$k$组，每组线段求一个交，求最大化所有交之和。</p>
<p>其实这个分组问题很容易想到的是用DP解法。那么DP解法我们不能<strong>枚举</strong>分组情况，从经验而言，一般是考虑<strong>连续的一系列线段</strong>构成最后一组这样子。那么怎么做才能使这样的DP成立呢？</p>
<p>首先我们把线段分成两类：一类线段可以包含其他的线段。那么如果把这个线段和其所包含的线段安排在一组，则不会对答案有新的贡献，要么把它单独分组，贡献其长度。另一类线段就是相互之间均不能包含，但可以有相交的部分。我们考虑把这些线段按左端点从小到大排序，那么右端点一定是单调不降的。这个时候，我们分析贪心，在这些线段中分组，一定是把连续的线段分成一组。因为通过画图可以知道，如果把排序后两条不相邻$i$,$j$的线段分成一组，那么我们取$k,i &lt;k&lt;j$，就会发现无论是$(i,k)$一组还是$(k,j)$一组，对答案的贡献都比$(i,j)$一组来的多。当然这里还有一个显然的事情就是一个组的线段越多，相交部分肯定倾向于越少。</p>
<p>于是我们就有了DP方程：</p>
<script type="math/tex; mode=display">
dp[i][j]=max_{k<i}\{dp[k][j-1]+R[k+1]\}-L[i],R[k+1] \geq L[i]</script><p>其中，$dp[i][j]$表示把第二类线段的前$i$条线段分成$j$组的最优情况。</p>
<p>那么这个方程我们可以用单调队列优化。</p>
<p>复杂度为$O(n^2)$</p>
<p><strong>算法标签</strong> <code>递推与动规</code> <code>贪心</code> <code>单调队列</code></p>
<h2 id="数论知识回顾"><a href="#数论知识回顾" class="headerlink" title="数论知识回顾"></a>数论知识回顾</h2><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>基本定义：对于一个正整数$n$,$\varphi(n)$代表比$n$小的且与$n$互质的正整数的个数。</p>
<p>计算性质：</p>
<script type="math/tex; mode=display">
\varphi(n)=\begin{cases}
n-1,&\text{n is a prime}\\
(p-1)p^{k-1},& n=p^k,\text{p is a prime}\\
\varphi(s)\cdot \varphi(t),&\text{n=st and (s,t)=1}\\
\varphi(k) ,&n=2k,\text{k is an odd}
\end{cases}</script><p>定义式：</p>
<script type="math/tex; mode=display">
\varphi(n)=n \cdot \prod_{i=1}^k (1-\frac{1}{p_i})</script><p>其中，$p_i$是$n$的质因子。</p>
<h3 id="判断质数的方法：Miller-Rabin"><a href="#判断质数的方法：Miller-Rabin" class="headerlink" title="判断质数的方法：Miller  Rabin"></a>判断质数的方法：Miller  Rabin</h3><h3 id="大整数质因数分解（探寻其质因子）-Pollard-Rho"><a href="#大整数质因数分解（探寻其质因子）-Pollard-Rho" class="headerlink" title="大整数质因数分解（探寻其质因子） Pollard Rho"></a>大整数质因数分解（探寻其质因子） Pollard Rho</h3><h3 id="特殊情况的组合数取模-Lucas"><a href="#特殊情况的组合数取模-Lucas" class="headerlink" title="特殊情况的组合数取模 Lucas"></a>特殊情况的组合数取模 Lucas</h3><script type="math/tex; mode=display">
C_n^m \equiv C_{n/p}^{m/p}\cdot C_{n \;mod\;p}^{m\;mod\;p}\;(mod \;p),\text{p is a prime}</script><h2 id="单调队列优化DP"><a href="#单调队列优化DP" class="headerlink" title="单调队列优化DP"></a>单调队列优化DP</h2><p>题目比如参考上面的G题</p>
<p>这个题的特点是左端点是单调不降的，右端点也是单调不降的。因此我们的单调队列里存下标值，比较的条件是$dp[k][…]+R[k+1]$,限制的条件是$R[k+1] \geq L[i]$,假设当前正在考虑第$i$条线段。</p>
<p>这个单调队列不适合用<code>STL</code>，原因是它两端都要删除添加，还是用数组手写比较方便。</p>
<p>从<strong>队首到队尾</strong>，<code>dp+R</code>这个值<strong>单调递减</strong>，同时下标是<strong>单调递增</strong>的。原因：分同样多的组，当我们可用的线段更多时，方案数更丰富，因此可以得到更好的答案。</p>
<p>二重循环第一重是考虑第几条线段，第二重是考虑分几组。而且需要注意的是，分几组要<strong>从大到小</strong>来，因为处理完第$i$条线段的信息时，第$i$条线段对应的<code>dp+R</code>也会更新到这一系列队列中，对于同样是$i$而分更多组的计算造成干扰（避免后效性）。</p>
<p>队列操作：每一次先在<strong>队首</strong>剔除掉虽然<code>dp+R</code>很大，但不满足$R[k+1]\geq L[i]$的元素，然后算出当前的$dp$值，再在<strong>队尾</strong>更新，把原本队尾<code>dp+R</code>更小的剔除掉。因为这些决策点下标又小，又不利于贡献后面的答案。</p>
<h2 id="Vector的简易写法和for的C-0x用法"><a href="#Vector的简易写法和for的C-0x用法" class="headerlink" title="Vector的简易写法和for的C++0x用法"></a>Vector的简易写法和for的C++0x用法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.<span class="built_in">resize</span>(n);  <span class="comment">//使得其大小为n，访问[0,n-1]</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>; <span class="comment">//大小为n的vector，访问同上</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="number">7</span>)</span></span>;<span class="comment">//一个元素，值为7</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> x : comp)   <span class="comment">//x为comp容器的遍历器，下面直接访问x如何</span></span><br><span class="line">&#123;</span><br><span class="line">    xxx</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i:&#123;-d,d&#125;)<span class="comment">//数值范围内遍历</span></span><br><span class="line"><span class="comment">//如果是vector&lt;vector &lt;xxx&gt; &gt; Q；这样的二维vector情形，则考虑</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;comp : comps) &#123;  <span class="comment">//不过遇事不决用auto 就可以了</span></span><br></pre></td></tr></table></figure>
<h3 id="代码能力"><a href="#代码能力" class="headerlink" title="代码能力"></a>代码能力</h3><p>1、<code>vector</code>的<code>size</code>是<code>unsigned int</code>类型。</p>
<p>2、STL Vector可能有重分配地址,*it 遍历器可能失效.</p>
<h2 id="计算几何学习"><a href="#计算几何学习" class="headerlink" title="计算几何学习"></a>计算几何学习</h2><p>见手写笔记</p>
<h2 id="编码细节"><a href="#编码细节" class="headerlink" title="编码细节"></a>编码细节</h2><p>1、<code>unsigned long long</code> 用<code>printf</code>输出时控制符为$\%llu$</p>
<p>2、最小值的预命令形式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a)&lt;(b) ? (a) : (b)</span></span><br></pre></td></tr></table></figure>
<p>3、Windows 命令行屏幕输出文字： <code>echo</code>+文字内容（不用引号）</p>
<p>4、LL的溢出，考虑用(__int128)或者慢速乘来解决。如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LL <span class="title">mul</span><span class="params">(LL a,LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (__int128)a*b%P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还要注意乘除的顺序，必要的时候先除后乘。</p>
<p>两个<code>int</code>相乘在<code>long long</code>的范围内判定，简单明确的写法是<code>1LL*i*j&gt;N</code>这类。</p>
<p>5、取模简化运算：预命令</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mod1(x) (x&gt;=MOD)&amp;&amp;(x-=MOD)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营3 C Minimum grid</title>
    <url>/2021/07/28/nowcoder3c/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>有一个$n \times n$的方阵，其中一些格子可以填数，其他格子均不能填数，且每行有一个最大值要求$b_i$，每列有一个最大值要求$c_i$，即填的数得保证这些最大值要求被满足。现在求最小的填数之和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n\leq 2\cdot 10^3\\</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>这种看起来具体需要“填一填”弄出具体方案的题目，不妨从<strong>必要条件</strong>入手去分析。我们猜测，在不填“多余的数”的情况下，这个和至少得是$\sum_{i=1}^n b_i+c_i$​​。很快我们发现这个必要条件可以优化，其实就是如果一个格子<strong>对应行列的最大值要求时相等</strong>的，那么其实填这个格子就<strong>节省</strong>了一个最大值。（如果不相等的话是不能实现“1换2”的）</p>
<p>所以我们的目标就是找出所有能够节省最大值的情况——<strong>同一行同一列</strong>只在上述的<strong>一个</strong>这种格子上放数，才能实现节省。于是我们用二分图求最大匹配来配置这些格子，即这种格子的行列连边，然后跑二分图匹配。再从答案中减掉匹配成功对应行列的最大值。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2010</span></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> b[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">namespace</span> graph &#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e4</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		node *nnext;</span><br><span class="line">	&#125; pool[<span class="number">2</span>*N],*h[<span class="number">2</span>*N];</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">-1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">		node *p=&amp;pool[++cnt];</span><br><span class="line">		p-&gt;v=v,p-&gt;nnext=h[u],h[u]=p;</span><br><span class="line">		node *q=&amp;pool[++cnt];</span><br><span class="line">		q-&gt;v=u,q-&gt;nnext=h[v],h[v]=q;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> connect[N];</span><br><span class="line">	<span class="keyword">bool</span> state[N];</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">		<span class="keyword">for</span>(node *p=h[u]; p; p=p-&gt;nnext) &#123;</span><br><span class="line">			v=p-&gt;v;</span><br><span class="line">			<span class="keyword">if</span>(!state[v]) &#123;</span><br><span class="line">				state[v]=<span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">if</span>(connect[v]==<span class="number">0</span> || <span class="built_in">dfs</span>(connect[v])) &#123;</span><br><span class="line">					connect[v]=u;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">LL <span class="title">hungary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		LL ret=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(state,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(state));</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">dfs</span>(j))</span><br><span class="line">				ret+=b[j];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u,v;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">		ans+=b[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c[i]);</span><br><span class="line">		ans+=c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(b[u]==c[v])</span><br><span class="line">			graph::<span class="built_in">addedge</span>(u,n+v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans - graph::<span class="built_in">hungary</span>());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>构图</tag>
        <tag>二分图最大匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu AI相关软件安装心得</title>
    <url>/2021/07/30/pythonDL/</url>
    <content><![CDATA[<p>在Ubuntu上安装<code>tensorflow</code>的过程真是一波三折，挺折腾人的。期间也查阅了不少CSDN的博客。不过也算是增进了对Ubuntu系统的了解和终端的使用吧。</p>
<p>好不容易入手了配有较高水平GPU的笔记本，当然要安装<code>tensorflow-gpu</code>版本了！不过经过摸索（呜呜呜），这个<code>gpu</code>版本的安装并不简简单单是一行pip就能解决的问题。依次要安装好<code>nvidia</code>显卡，<code>CUDA</code>和<code>cuDNN</code>,当然还有<code>Anaconda</code>等。由于之前出于省事安装了个<code>LambdaStack</code>，现在这些个软件包其实是混乱的，就可能许多软件包已经下载到电脑里了，只不过没有启用或者依赖关系没有解决云云。</p>
<p>具体的命令行就不写了，网上大多能查到。就记一记在自己电脑上试的坑。</p>
<h2 id="NVIDIA显卡的安装"><a href="#NVIDIA显卡的安装" class="headerlink" title="NVIDIA显卡的安装"></a>NVIDIA显卡的安装</h2><p>1、要禁用、卸载Ubuntu自带的nouveau驱动</p>
<p>2、卸载曾经安装残存的<code>nvidia</code>驱动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove nvidia-*</span><br></pre></td></tr></table></figure>
<p>3、安装NVIDIA驱动时必须要关闭图形界面<code>Ctrl+Alt+F1</code>进入<code>tty</code>虚拟命令行，把命令先写下来，因为一时上不了网。</p>
<p>大概有这么几条</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo service lightdm stop  //关闭图形界面</span><br><span class="line">sudo chmod a+x ...</span><br><span class="line">sudo ./... (此处为驱动) -no-x-check -no-nouveau-check -no-opengl-files</span><br></pre></td></tr></table></figure>
<p>然后一通安装，期间有设置安全启动密码什么的，最好记住。然后重启</p>
<p>检查是否安装成功，执行<code>nvidia-smi</code>如果能够看到一张大表格就行了</p>
<p>还有一条<code>modprobe nvidia</code>似乎是启用</p>
<p>4、此外必要时需要在BIOS中设置关闭安全启动。</p>
<h2 id="CUDA的安装"><a href="#CUDA的安装" class="headerlink" title="CUDA的安装"></a>CUDA的安装</h2><p>最麻烦的就是出现诸如“下列软件包有未满足的依赖关系： cuda : 依赖: cuda-11-4 (&gt;= 11.4.xxx) 但是它将不会被安装”的报错。针对这个报错从网上弄了好几种设置，也不知道到底哪个是真正奏效的（汗）</p>
<ul>
<li><code>gcc/g++</code>的降级（这个还是很重要的，主要用到<code>update-alternatives</code>命令）</li>
<li>开启Ubuntu软件更新（重要位置和推荐）</li>
<li>用aptitude代替apt-get（但我后来没用deb安装包似乎这一条没什么用了）</li>
</ul>
<p>虽然我的机子是Ubuntu20.04，但最后下载的是CUDA11.4版本且适用于Ubuntu18.04<code>run</code>文件安装成功过的。</p>
<h2 id="cuDNN的安装"><a href="#cuDNN的安装" class="headerlink" title="cuDNN的安装"></a>cuDNN的安装</h2><p>这个就相对好弄多了。</p>
<p>只要先装<code>Runtime Library</code>再装<code>Developer Library</code>和<code>Sample</code>三个安装包即可。</p>
<p>验证成功安装时，将<code>mnistCUDNN</code>的实例拷到个人目录下，然后还得更新一波FreeImage，以及在make的时候sudo一下，Test Passed.</p>
<h2 id="TensorFlow-GPU的安装"><a href="#TensorFlow-GPU的安装" class="headerlink" title="TensorFlow-GPU的安装"></a>TensorFlow-GPU的安装</h2><p>还是用conda来做比较方便。首先换源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://tuna.moe/oh-my-tuna/oh-my-tuna.py</span><br><span class="line">python oh-my-tuna.py</span><br></pre></td></tr></table></figure>
<p>然后执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n tf python=3.8</span><br><span class="line">pip install -U pip</span><br><span class="line">conda activate tf</span><br><span class="line">pip install -U tensorflow-gpu</span><br></pre></td></tr></table></figure>
<p>差不多就可以了。</p>
<p>最后验证一下即可。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 G Product</title>
    <url>/2021/07/27/nowcoder4g/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>给定三个整数$n,k,D$,设数列$a_i,i=1,2,…,n$,求对于所有数列满足$\forall i \in [1,n],a_i \geq 0$​且$\sum_{i=1}^na_i=D$​的情况下，</p>
<script type="math/tex; mode=display">
\frac{D!}{\prod_{i=1}^n(a_i+k)!}</script><p>的总和。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><script type="math/tex; mode=display">
1 \leq n \leq 50\\
0\leq k \leq 50\\
D \leq 10^8</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>此题比较神仙。首先分母上$(a_i+k)!$​不太好看，假设一个$a_i :=a_i+k$​.我们考虑一个<strong>组合模型</strong>，一个长度为D的数列，每个位置上可以填$[1,n]$中的任何正整数，一共有多少中填法。通过算两次，假设我们枚举$i$出现的次数为$a_i$​，或者直接乘法原理，那么这个组合模型的描述为</p>
<script type="math/tex; mode=display">
(\sum_{a_i\geq0}=D) \prod_{i=1}^n \frac{D!}{a_i!}=n^D</script><p>那么回到本题。如果不要求$a_i \geq 0$即$a_i+k \geq k$时，则答案就是$n^{D+nk}$</p>
<p>现在问题就是必须要求$a_i+k\geq k$。因此我们用容斥原理做。</p>
<p>由于$n,k$都比较小，所以不妨记$dp[i][j]$表示“有$i$个数不满足要求且这$i$个数的和是$j$”，对于剩下的$n-i$​个数可以满足要求也可以不满足要求，其和也是确定的$D+nk-j$.因此我们可以求出”至少有$i$​个数不满足要求时对答案的贡献”:</p>
<script type="math/tex; mode=display">
C_{n}^{i} \cdot \sum_j dp[i][j]\cdot(n-i)^{D+nk-j}</script><p>因此答案就是$n^{D+nk}$减去”至少一个违反条件的”加上“至少两个违反条件的”减去“至少三个违反条件的”…如此递推即可。</p>
<p>最后再乘上$\frac{D!}{(D+nk)!}$满足题意。</p>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>2021牛客暑期多校训练营4 H题</title>
    <url>/2021/07/27/test/</url>
    <content><![CDATA[<h2 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h2><p>考虑$x=\prod_{i}p_i^{a_i}$,$y=\prod_{i}p_i^{b_i}$.定义$x \bigotimes y$=$\prod_{i}p_i^{|a_i-b_i|}$,现在给定一个数列$a[1…n]$，求出</p>
<script type="math/tex; mode=display">
b[i]=\sum_{1 \leq j,k \leq n,j \bigotimes k=i}a_jk^c</script><h2 id="分析与解"><a href="#分析与解" class="headerlink" title="分析与解"></a>分析与解</h2><p>首先通过$|a_i-b_i|=max(a_i,b_i)-min(a_i,b_i)$来理解这个定义本质是$\frac{lcm(a,b)}{gcd(a,b)}$,故进一步得到</p>
<script type="math/tex; mode=display">
i=\frac{j}{gcd} \cdot \frac{k}{gcd}</script><p>那么不妨令</p>
<script type="math/tex; mode=display">
s=\frac{j}{gcd},t=\frac{k}{gcd}</script><p>故</p>
<script type="math/tex; mode=display">
i=s \cdot t \\(s,t)=1</script><p>因此</p>
<script type="math/tex; mode=display">
b[i]=\sum_s (\frac{i}{s})^c \sum_{gcd} (a_{s \cdot gcd})\cdot gcd^c</script><p>由此可见后面这个$gcd$的部分可以通过对于一个数枚举其倍数预处理得到，其复杂度为</p>
<script type="math/tex; mode=display">
n \cdot \sum_{i=1}^N \frac{1}{i} =nlogn</script><p>前面这个$s$的枚举是$O(n\sqrt n)$,但并不满。因此总复杂度是可以接受的。</p>
<p>此外，对于$s,t$并没有大小之分，但是需要保证$s \cdot gcd ,t \cdot gcd \leq n$,因此需要在上述计算中选择较小的$gcd$上限来运算。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>本题在考场上低级错误在于快速幂。</p>
<p>枚举因子时<code>sqrt</code>应当提前算出！</p>
<p>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1001000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) (a) &lt; (b) ? (a) : (b)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> c=<span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">&#x27;0&#x27;</span> || c&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>)f=<span class="number">-1</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ret=ret*<span class="number">10</span>+c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c=<span class="built_in">getchar</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="string">&#x27;0&#x27;</span>&lt;=c &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> ret*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">quick_pow</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">    LL ret=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)ret=ret*a%MOD;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">LL b[MAXN];</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line">vector&lt;LL&gt; rela[MAXN];</span><br><span class="line">LL my_pow[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;H.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    LL sum=<span class="number">0</span>;</span><br><span class="line">    LL now;</span><br><span class="line">    <span class="keyword">int</span> s,t,qrt;</span><br><span class="line">    n=<span class="built_in">mread</span>(),c=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)a[i]=<span class="built_in">mread</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)my_pow[i]=<span class="built_in">quick_pow</span>(i,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        now=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i,k=<span class="number">1</span>; j&lt;=n; j+=i,k++) &#123; <span class="comment">//gcd enum</span></span><br><span class="line">            now=(now+<span class="number">1ll</span>*a[j]*my_pow[k]%MOD+MOD)%MOD;</span><br><span class="line">            rela[i].<span class="built_in">push_back</span>(now);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        qrt=<span class="built_in">sqrt</span>((<span class="keyword">double</span>)i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=qrt; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i%j!=<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            s=j,t=i/j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">gcd</span>(s,t)!=<span class="number">1</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(s!=t) &#123;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[t]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">                b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[t][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">            &#125; <span class="keyword">else</span>  b[i]=(b[i]+<span class="number">1ll</span>*my_pow[s]*rela[s][<span class="built_in">min</span>(n/s,n/t)<span class="number">-1</span>]%MOD)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)sum=sum^b[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm Competitions</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
</search>
